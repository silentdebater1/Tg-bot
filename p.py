import random 
import nest_asyncio
import random
import json
import os
import sys
import base64
import shutil
from io import BytesIO
import aiohttp
from telegram import InputFile
from telegram import Update
from telegram.helpers import mention_html, escape_markdown
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
)
import logging

# Logger setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
nest_asyncio.apply()

TOKEN = "8482426081:AAFIgfRMBj4KdIqGSlxtjPCbatocUl_Gf-s"
OWNER_USERNAME = "@Problem_Zenki"
OWNER_ID = 7808603044
CHANNEL_ID = -1002153191249  
GROUP_ID = -1001234567890  # á€á€„á€·á€º group id
GROUP_ID_FILE = "group_id.txt"
LOG_FILE = "send__command_log.json"

# á€–á€­á€¯á€„á€ºá€™á€›á€¾á€­á€›á€„á€º [] á€”á€²á€· á€…á€•á€¼á€®á€¸ á€–á€”á€ºá€á€®á€¸á€‘á€¬á€¸á€™á€šá€º
if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump([], f, ensure_ascii=False, indent=2)

def write_log(entry):
    """log á€–á€­á€¯á€„á€ºá€‘á€²á€€á€­á€¯ entry á€¡á€á€…á€ºá€‘á€Šá€·á€ºá€›á€”á€º"""
    data = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                if not isinstance(data, list):
                    data = []
        except Exception:
            # JSON corrupted á€–á€¼á€…á€ºá€›á€„á€º reset
            data = []

    # á€¡á€á€…á€ºá€‘á€Šá€·á€º
    data.append(entry)

    # overwrite á€•á€¼á€”á€ºá€á€­á€™á€ºá€¸
    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        # Log write fail á€›á€„á€º console á€‘á€²á€™á€¾á€¬á€•á€² print
        print(f"âŒ Log write failed (ignored): {e}")

OWNER_USERNAME_LC = OWNER_USERNAME.lower()

# ====== Owner check (username or user_id support) ======
def is_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user == OWNER_ID
    # assume string username
    username = user.lower()
    owner = OWNER_USERNAME.lower()
    if not username.startswith("@"):
        username = "@" + username
    if not owner.startswith("@"):
        owner = "@" + owner
    return username == owner

# ====== Admin or Owner check (username or user_id support) ======
def is_admin_or_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user in ADMINS or user == OWNER_ID

    # assume string username
    username = user.lower()
    if not username.startswith("@"):
        username = "@" + username

    owner = OWNER_USERNAME.lower()
    if not owner.startswith("@"):
        owner = "@" + owner

    # username á€€á€­á€¯ owner á€”á€²á€· admin list á€”á€¾á€…á€ºá€á€¯á€™á€¾á€¬á€…á€…á€ºá€™á€šá€º
    return username == owner or username in [a.lower() if a.startswith("@") else "@" + a.lower() for a in ADMINS]

GROUP_FILE = "groups.json"

# Group ID á€á€½á€±á€€á€­á€¯ á€–á€­á€¯á€„á€ºá€‘á€²á€€á€”á€± Load
def load_groups():
    if not os.path.exists(GROUP_FILE):
        return []
    with open(GROUP_FILE, "r") as f:
        return json.load(f)

# Group ID á€¡á€á€…á€ºá€…á€¬á€›á€„á€ºá€¸á€œá€¯á€¶á€¸á€€á€­á€¯ overwrite á€œá€¯á€•á€º
def save_groups(group_ids):
    with open(GROUP_FILE, "w") as f:
        json.dump(group_ids, f)

# Group ID á€á€…á€ºá€á€¯á€á€»á€„á€ºá€¸á€…á€®á€‘á€Šá€·á€ºá€•á€¼á€®á€¸ á€á€­á€™á€ºá€¸
def save_group_id(group_id):
    group_ids = load_groups()
    if group_id not in group_ids:
        group_ids.append(group_id)
        save_groups(group_ids)

# Group ID á€€á€­á€¯ á€á€½á€„á€ºá€¸á€–á€­á€¯á€· handler
async def track_group_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type in ["group", "supergroup"]:
        save_group_id(chat.id)

ADMIN_FILE = "admins.json"

DEFAULT_ADMINS = [
    "@Codra_ricky",
    "@SolveBack",
    "@Joy_fav_Lyushi",
    "@Dbngaduu",
    "@Xnhdsi",
    "@htetaunglin9999999",
    "@ifwemo4",
]

# list -> set á€•á€¼á€±á€¬á€„á€ºá€¸á€•á€¼á€®á€¸ lowercase á€•á€¼á€±á€¬á€„á€ºá€¸
ADMIN_USERNAMES = {a.lower() for a in DEFAULT_ADMINS}

ADMINS_LC = ADMIN_USERNAMES  # á€’á€®á€¡á€á€­á€¯á€„á€ºá€¸á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€•á€«á€á€šá€º

ACTIVE_ATTACKS = {}
AUTO_DIE = {}
auto_replies = [ "á€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€²á€·á€á€á€„á€ºá€†á€²á€›á€„á€ºá€™á€„á€ºá€¸á€á€­á€¯á€·á€„á€¼á€­á€™á€ºá€á€¶á€›á€™á€šá€ºá€†á€­á€¯á€á€¬á€™á€„á€ºá€¸á€á€­á€¯á€·á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€”á€²á€·á€•á€±á€¸á€œá€­á€¯á€¸á€•á€¼á€®á€¸á€™á€„á€ºá€¸á€‘á€½á€€á€ºá€œá€¬á€á€¬á€œá€±á€á€¬á€¸á€™á€­á€¯á€€á€º", "á€™á€„á€ºá€¸á€…á€±á€¬á€ºá€–á€¬á€á€Šá€ºá€™á€•á€±á€¸á€˜á€¯á€•á€«á€œá€¬á€¸á€œá€½á€á€ºá€œá€­á€¯á€€á€ºâ€Œá€±á€”á€¬á€ºá€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€®á€€á€­á€¯á€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€„á€«á€·á€†á€®á€œá€­á€„á€ºá€€á€»á€½á€”á€ºá€¡á€–á€¼á€…á€ºá€á€…á€¬á€¸á€”á€±á€›á€á€šá€º", "á€˜á€¬á€˜á€¬á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€á€šá€ºá€Ÿá€¯á€á€ºá€œá€¬á€¸ á€á€¼á€±á€‘á€±á€¬á€€á€ºá€‘á€­á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±", "á€Ÿá€€á€ºá€€á€œá€…á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€€á€œá€…á€ºá€€á€¼á€®á€¸á€€á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€˜á€²Typingá€†á€­á€¯á€›á€„á€ºá€á€±á€¬á€·á€œá€­á€•á€ºá€‚á€½á€„á€ºá€¸á€‘á€¯á€™á€¾á€•á€¼á€®á€¸á€™á€šá€·á€ºá€€á€±á€¬á€„á€º", "á€„á€«á€›á€²á€·á€…á€¬á€€á€­á€¯á€á€»á€±á€•á€–á€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€¼á€®á€¸á€€á€™á€á€„á€ºá€•á€±á€¸á€‘á€¬á€¸á€˜á€°á€¸á€œá€±á€€á€½á€¬", "á€™á€„á€ºá€¸á€…á€€á€±á€¸á€€á€’á€«á€•á€²á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€¡á€¯á€”á€ºá€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€€á€¼á€±á€¬á€€á€ºá€€á€”á€ºá€€á€”á€ºá€á€¬á€œá€¬á€¸á€¡á€€á€ºá€á€¬á€€", "á€˜á€¬á€á€½á€±á€•á€¼á€±á€¬á€”á€±á€á€¬á€’á€®á€…á€±á€¬á€€á€ºá€›á€°á€¸á€‚á€±á€«á€€á€ºá€á€®á€¸á€”á€²á€·á€€á€á€±á€¬á€·", "á€•á€¼á€±á€¬á€á€»á€„á€ºá€á€¬á€á€½á€±á€•á€¼á€±á€¬á€•á€®á€á€…á€ºá€€á€­á€¯á€šá€ºá€á€±á€¬á€„á€ºá€œá€½á€á€ºá€•á€»á€±á€¬á€ºá€”á€±á€á€¬á€œá€¬á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€±á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€€á€»á€•á€ºá€™á€•á€¼á€Šá€·á€ºá€˜á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€›á€„á€ºá€€á€½á€²á€™á€œá€¬á€¸", "á€™á€„á€ºá€¸á€”á€¬á€™á€Šá€ºá€€á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€•á€±á€«á€·", "á€™á€„á€ºá€¸á€€á€˜á€¬á€œá€­á€¯á€·á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€¼á€…á€ºá€”á€±á€›á€á€¬", "á€šá€»á€±á€¬á€„á€·á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€„á€«á€™á€±á€¸á€”á€±á€á€šá€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€˜á€šá€ºá€•á€¼á€±á€¸á€™á€¾á€¬á€•á€¼á€”á€ºá€œá€¬á€€á€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€á€±á€¬á€á€®á€¸á€•á€»á€±á€¬á€·á€á€»á€€á€ºá€€á€á€±á€¬á€·á€‚á€½á€±á€¸á€á€®á€¸á€œá€¬á€•á€²", "á€¡á€¬á€á€®á€¸á€šá€±á€¬á€„á€ºá€á€¬á€œá€»á€¾á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€±á€¬á€á€¬á€¸á€œá€±ğŸ‘ğŸ¤¨ğŸ¤¨", "Hiá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€…á€¬á€›á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€¡á€”á€°á€œá€€á€ºá€”á€²á€·á€€á€¯á€œá€¬á€¸á€›á€±", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€¡á€á€¯á€™á€˜á€¬á€€á€­á€¯á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€œá€²ğŸ˜³", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸", "á€™á€¡á€±á€¸á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€¬á€¸á€”á€¬á€¸á€›á€„á€ºá€„á€«á€·á€á€•á€Šá€·á€º", "á€„á€«á€·á€¡á€™á€­á€”á€·á€ºá€™á€›á€•á€²á€˜á€¬á€€á€­á€¯á€”á€¬á€¸á€á€»á€„á€ºá€á€¬á€œá€²á€á€½á€±á€¸á€™á€á€¬á€¸á€™á€»á€­á€¯á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€–á€®á€†á€”á€ºá€á€¬á€œá€¬á€¸á€€á€½ğŸ˜¨", "á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸á€á€½á€±á€¸á€™á€á€¬á€¸ğŸ˜", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€Šá€±á€¬á€„á€ºá€¸á€”á€±á€•á€®á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€€á€ºá€á€½á€±á€€á€¡á€œá€¯á€•á€ºá€€á€¼á€™á€ºá€¸á€œá€¯á€•á€ºá€á€²á€·á€œá€€á€ºá€•á€²á€˜á€¬á€€á€­á€¯á€Šá€±á€¬á€„á€ºá€¸á€á€»á€„á€ºá€šá€±á€¬á€„á€ºá€†á€±á€¬á€„á€ºá€á€¬á€œá€²", "á€Ÿá€”á€ºá€•á€²á€›á€¾á€­á€á€šá€ºâ€Œá€™á€¬á€”á€ºá€™á€›á€¾á€­á€˜á€°á€¸á€™á€„á€ºá€¸á€œá€­á€¯á€á€½á€±á€¸á€€ğŸ˜›", "á€˜á€¬á€†á€„á€ºá€á€¼á€±á€á€½á€±á€œá€¬á€•á€±á€¸á€”á€±á€á€¬á€™á€á€”á€¬á€¸á€˜á€°á€¸á€„á€«á€€", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€€á€¼á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€á€±á€¬á€„á€ºá€”á€²á€·á€›á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€€á€­á€¯á€€á€ºá€œá€±á€™á€„á€ºá€¸á€¡á€™á€±á€…á€±á€¬á€€á€ºá€•á€á€ºá€™á€œá€­á€¯á€·á€”á€¬á€¸á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€²á€·á€…á€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€œá€°á€œá€¬á€¸á€á€½á€±á€¸á€œá€¬á€¸á€™á€„á€ºá€¸á€€á€™á€á€²á€€á€½á€²á€á€±á€¬á€·á€˜á€°á€¸", "á€™á€„á€ºá€¸á€™á€­á€˜á€„á€«á€œá€­á€¯á€¸á€„á€«á€œá€­á€¯á€¸á€™á€½á€±á€¸á€‘á€¬á€¸á€á€²á€·á€á€¬á€¸á€•á€²á€™á€„á€ºá€¸á€€", "á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€œá€­á€¯á€¸á€œá€­á€¯á€€á€ºá€œá€­á€¯á€·á€™á€„á€ºá€¸á€€á€„á€«á€·á€á€¬á€¸á€–á€¼á€…á€ºá€€á€±á€¬á€œá€¬á€¸á€á€±á€¬á€á€®á€¸ğŸ¤‘", "á€á€±á€¬á€á€®á€¸á€™á€”á€¬á€¸á€”á€²á€·á€œá€±á€€á€­á€¯á€€á€ºá€¡á€½á€™á€ºá€¸", "á€•á€»á€±á€¬á€·á€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€’á€°á€’á€°á€’á€”á€ºá€’á€”á€ºá€€á€±á€¬á€„á€º", "á€á€­á€•á€«á€•á€¼á€®á€á€­á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬", "á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€¡á€á€¯á€™á€¾á€€á€°á€•á€«á€€á€šá€ºá€•á€«á€’á€°á€•á€«á€’á€”á€ºá€•á€«á€œá€¯á€•á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€»á€€á€ºá€”á€¾á€¬á€œá€­á€¯á€™á€»á€€á€ºá€”á€¾á€¬á€›á€„á€«á€·á€˜á€±á€¬á€¡á€á€„á€ºá€¸á€€á€•á€ºá€™á€•á€¼á€®á€¸á€™á€¾á€¡á€á€¯á€˜á€¬á€•á€¼á€”á€ºá€€á€­á€¯á€€á€ºá€á€»á€„á€ºá€”á€±á€á€¬á€œá€Šá€ºá€¸á€Ÿá€±á€·á€›á€±á€¬á€„á€ºá€á€½á€±á€¸á€á€°á€á€±á€¬á€„á€ºá€¸á€…á€¬á€¸", "á€›á€¯á€•á€ºá€†á€­á€¯á€¸á€™á€á€¬á€¸á€á€±á€á€»á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€†á€›á€¬á€á€á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€²á€·á€œá€­á€¯á€€á€•á€ºá€á€­á€¯á€¸á€œá€±á€¸á€˜á€±á€¬á€™á€›á€¯á€¶á€”á€²á€·á€á€±á€¬á€·á€™á€›á€˜á€°á€¸", "á€™á€„á€ºá€¸á€€á€œá€°á€á€€á€¬á€˜á€±á€¬á€™á€œá€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€±á€¬á€á€¬á€œá€²", "á€œá€½á€šá€ºá€œá€­á€¯á€€á€ºá€á€¬á€€á€½á€¬á€¡á€”á€­á€¯á€„á€ºá€šá€°á€™á€­á€•á€¼á€”á€ºá€•á€®ğŸ˜", "á€¡á€²á€·á€œá€±á€¬á€€á€ºá€‡á€”á€²á€·á€™á€”á€­á€¯á€„á€ºá€á€±á€¸á€˜á€°á€¸á€™á€„á€ºá€¸á€„á€«á€·á€€á€­á€¯", "á€€á€¼á€­á€¯á€¸á€…á€¬á€¸á€¡á€¯á€”á€ºá€¸á€á€¬á€¸á€–á€±á€¬á€€á€ºá€œá€­á€¯á€á€±á€¸á€á€šá€º", "á€šá€»á€±á€¬á€„á€·á€ºá€¡á€€á€­á€¯á€€á€ºá€Šá€¶á€·á€á€²á€·á€á€½á€±á€¸á€˜á€šá€ºá€”á€±á€›á€¬á€á€„á€ºá€•á€¯á€”á€ºá€¸á€•á€¼á€”á€ºá€•á€®á€œá€²", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€™á€€á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€™á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€•á€»á€±á€¬á€·á€á€¬á€™á€„á€ºá€¸á€•á€²á€›á€¾á€­á€á€šá€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€¯á€”á€ºá€¸á€™á€…á€¬á€¸á€”á€²á€·á€á€±á€¬á€á€®á€¸á€›á€¯á€”á€ºá€¸á€™á€¾á€¬á€á€¬á€†á€€á€ºá€›á€¯á€”á€ºá€¸", "á€€á€¼á€±á€¬á€€á€ºá€”á€±á€á€¬á€œá€¬á€¸á€™á€„á€ºá€¸á€€", "á€˜á€¬á€œá€­á€¯á€·á€€á€¼á€±á€¬á€€á€ºá€•á€¼á€”á€±á€á€¬á€œá€²á€á€½á€±á€¸á€œá€±á€¸", "á€™á€»á€€á€ºá€”á€¾á€¬á€„á€šá€ºá€œá€±á€¸á€”á€²á€·á€¡á€á€”á€¬á€¸á€á€¶á€á€±á€¬á€·á€™á€¬á€œá€¬á€¸", "á€á€±á€¸á€á€±á€¸á€€á€€á€­á€¯á€€á€ºá€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€™á€„á€ºá€¸á€…á€®á€€á€¡á€”á€¶á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸", "á€á€½á€±á€¸á€”á€¶á€‘á€½á€€á€ºá€”á€±á€á€šá€ºá€á€½á€±á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€€", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€˜á€šá€ºá€€á€­á€¯á€•á€¼á€±á€¸á€™á€¬", "á€á€±á€¬á€á€¬á€¸á€€á€­á€¯á€€á€ºá€•á€«á€¡á€¯á€”á€ºá€¸á€¡á€šá€¬á€¸á€™á€•á€¼á€±á€–á€¼á€…á€ºá€”á€±á€á€šá€º", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€›á€±á€™á€„á€ºá€¸á€›á€¯á€”á€ºá€¸á€€á€”á€ºá€”á€±á€›á€•á€®á€œá€¬á€¸á€Ÿ", "á€™á€„á€ºá€¸á€™á€±á€…á€•á€á€½á€±á€á€„á€ºá€•á€¼á€±á€¬á€”á€±á€á€¬á€œá€¬á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸", "á€¡á€±á€¸á€¡á€²á€·á€á€±á€¬á€·á€™á€„á€ºá€¸á€€á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€•á€±á€«á€·á€Ÿá€¯á€á€ºá€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€†á€›á€¬á€•á€¼á€á€¬á€”á€¬á€€á€­á€¯á€¡á€›á€¾á€¯á€¶á€¸á€•á€±á€¸á€•á€®á€•á€±á€«á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€á€±á€¬á€á€®á€¸á€›á€¾á€¯á€¶á€¸á€”á€±á€á€±á€¬á€·á€™á€»á€€á€ºá€”á€¾á€¬á€€á€á€…á€ºá€™á€»á€­á€¯á€¸", "á€†á€›á€¬Problemá€¡á€›á€¾á€­á€”á€ºá€¡á€á€«á€€á€á€±á€¬á€ºá€›á€¯á€¶á€™á€»á€€á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€€á€¼á€Šá€·á€ºá€™á€›á€˜á€°á€¸á€Šá€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€•á€¼á€”á€ºá€œá€­á€¯á€¸á€á€²á€·á€€á€­á€¯á€™á€±á€€á€­á€¯  á€œá€­á€¯á€¸á€á€¬á€¸á€•á€±á€«á€·á€™á€„á€ºá€¸á€€ğŸ˜³", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "Sorry á€•á€²á€šá€–á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€„á€«á€œá€€á€ºá€œá€½á€”á€ºá€¡á€œá€­á€¯á€¸á€œá€½á€”á€ºá€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€›á€¾á€±á€¬á€•á€®", "á€™á€„á€ºá€¸á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯á€–á€¼á€²á€•á€¼á€®á€¸ á€”á€¶á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€šá€º á€¡á€¬á€•á€¯á€á€ºá€…á€±á€¬á€º á€•á€«á€¸á€…á€•á€ºá€€á€­á€¯ á€•á€­á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€º", "á€…á€…á€ºá€˜á€±á€¸á€›á€¾á€±á€¬á€„á€ºá€†á€­á€¯á€•á€¼á€®á€¸ á€›á€•á€ºá€€á€½á€•á€ºá€‘á€²á€™á€¾á€¬ á€•á€­á€¯á€€á€ºá€†á€¶á€œá€­á€¯á€€á€ºá€á€±á€¬á€„á€ºá€¸á€”á€±á€á€šá€º á€™á€á€¬á€€á€±á€¬á€„á€º", "á€˜á€±á€¬á€™", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€†á€­á€¯á€á€¬á€œá€€á€ºá€á€¶á€œá€¬á€¸", "á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€Ÿá€¯á€á€ºá€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€™á€±á€–á€¬á€á€Šá€ºá€™á€”á€¬á€›á€±á€¸á€œá€°á€…á€Šá€ºá€›á€²á€·á€œá€¬á€¸", "á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€‘á€™á€„á€ºá€¸á€™á€á€»á€€á€ºá€€á€»á€½á€±á€¸á€”á€­á€¯á€„á€ºá€–á€°á€¸á€œá€¬á€¸", "á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€˜á€¬á€œá€­á€¯á€·á€›á€¾á€¯á€¶á€¸â€Œá€™á€²á€™á€²á€”á€±á€á€¬á€œá€Šá€ºá€¸", "á€„á€«á€œá€­á€°á€¸á€™á€á€¬á€¸á€á€€á€ºá€„á€¼á€­á€™á€ºá€€á€¯á€á€ºá€”á€±á€œá€¾á€á€»á€‰á€ºá€œá€¬á€¸", "á€™á€”á€­á€¯á€„á€ºá€›á€„á€ºá€á€±á€¬á€· left the group á€á€¬á€œá€¯á€•á€ºá€œá€­á€¯á€€á€ºá€á€±á€¬á€·á€Šá€®á€›á€±", "á€Ÿá€¬á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€¬á€á€€á€šá€ºá€–á€¼á€…á€ºá€”á€­á€¯á€„á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€˜á€¬á€œá€­á€¯á€·á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯á€á€¶á€•á€¼á€±á€¬á€”á€±á€›á€á€¬á€œá€Šá€ºá€¸", "á€”á€¬á€¸á€™á€œá€Šá€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€á€²á€·á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±á€€á€­á€¯á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€…á€¯á€¶á€›á€¾á€„á€ºá€¸á€•á€¼á€•á€±á€¸á€•á€«", "á€¡á€™á€¾á€”á€ºá€á€›á€¬á€¸á€›á€²á€·á€˜á€€á€ºá€á€±á€¬á€ºá€á€¬á€¸á€†á€­á€¯á€›á€„á€ºá€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€¡á€™á€¾á€”á€ºá€á€€á€šá€ºá€œá€­á€¯á€¸á€á€¬á€á€”á€ºá€á€¶á€•á€«", "á€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€á€½á€€á€ºá€˜á€¬á€œá€­á€¯á€·á€™á€²á€”á€±á€á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€•á€±á€«á€€á€¼á€®á€¸á€á€…á€ºá€šá€±á€¬á€€á€ºá€‘á€²á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€€á€±á€¬á€„á€ºá€¸á€•á€«á€•á€¼á€®á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€•á€¼á€®", "á€„á€«á€…á€­á€á€ºá€Šá€…á€ºá€”á€±á€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€œá€®á€¸á€…á€¯á€•á€ºá€™á€€á€»á€½á€™á€ºá€¸á€œá€­á€¯á€·", "á€†á€€á€ºá€€á€­á€¯á€€á€ºá€•á€±á€¸á€•á€«á€˜á€±á€¬á€™á€›á€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€á€¯á€˜á€¡á€†á€„á€ºá€•á€¼á€±á€›á€²á€·á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€°á€™á€²", "á€Ÿá€±á€¸á€¡á€›á€¾á€¯á€¶á€¸á€á€™á€¬á€¸á€œá€€á€ºá€•á€”á€ºá€¸á€€á€»á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€–á€¬á€á€Šá€ºá€™á€€á€­á€¯ á€™á€„á€ºá€¸á€‰á€®á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€”á€±á€•á€¼á€®", "á€™á€á€­á€á€»á€„á€ºá€˜á€°á€¸á€€á€½á€¬á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€œá€­á€¯á€€á€º", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€˜á€¬á€á€±á€•á€¼á€±á€¬", "á€œá€®á€¸á€•á€²á€†á€²á€”á€±á€á€¬á€á€±á€¬á€„á€ºá€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€›á€¾á€­á€›á€¾á€­á€†á€²á€á€²á€·á€„á€«á€·á€€á€­á€¯á€¡á€¬á€¸á€€á€»á€…á€™á€ºá€¸á€•á€«á€Ÿ", "á€œá€°á€á€€á€¬á€¸á€œá€­á€¯á€¸á€á€¶á€›á€á€²á€·á€¡á€™á€±á€€á€”á€±á€™á€½á€±á€¸á€œá€¬á€á€²á€·á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€™á€á€¬á€¸", "á€Ÿá€­á€á€ºá€€á€±á€¬á€„á€º", "á€á€±á€™á€šá€ºá€”á€±á€¬á€º", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€á€¯á€”á€ºá€›á€™á€šá€ºá€œá€± á€™á€„á€ºá€¸á€›á€„á€ºá€†á€­á€¯á€„á€ºá€”á€±á€›á€á€²á€·á€œá€°á€€ Problem  á€œá€±á€Šá€®", "á€™á€”á€±á€·á€á€”á€±á€·á€€á€™á€¾á€†á€­á€¯á€›á€¾á€šá€ºá€‘á€²á€á€„á€ºá€œá€¬á€•á€¼á€®á€¸á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€­á€¯á€•á€¯á€”á€ºá€€á€”á€ºá€á€¬á€á€±á€’á€á€ºá€”á€±á€¬á€ºá€á€½á€±á€¸á€›", "á€›á€¯á€€á€¹á€á€†á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸ á€„á€«á€·á€œá€±á€¬á€€á€ºá€¡á€‘á€¬á€™á€€á€»á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€”á€±á€á€¬á€œá€¬á€¸", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€…á€±á€¬á€€á€ºá€›á€¯á€•á€ºá€†á€­á€¯á€¸", "á€…á€±á€¬á€€á€ºá€¡á€‘á€¬á€€á€»á€”á€Šá€ºá€¸á€á€„á€ºá€•á€±á€¸á€™á€šá€ºá€–á€±á€–á€±á€á€±á€«á€º", "á€œá€®á€¸á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€”á€²á€·á€á€½á€±á€¸á€™á€€ á€œá€¬á€šá€¾á€¥á€ºá€”á€±á€á€¬", "á€‚á€»á€•á€­á€¯á€¸á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€¡á€­á€™á€ºâ€Œá€±á€™á€¼á€¬á€„á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€€á€¼á€½á€€á€ºá€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€’á€­á€¯á€„á€ºá€†á€­á€¯á€†á€±á€¬á€œá€­á€¯á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€»á€­á€¯á€¸á€á€¯á€¶á€¸á€á€¼á€„á€ºá€”á€±á€á€¬á€á€½á€±á€¸á€™á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€”á€¬á€‡á€®á€™á€á€¬á€¸", "á€šá€±á€›á€¾á€°á€€á€­á€¯á€¸á€€á€½á€šá€ºá€á€²á€·á€€á€¯á€œá€¬á€¸á€Ÿá€œá€®á€¸á€˜á€²", "á€˜á€¯á€›á€¬á€¸á€á€á€„á€ºá€œá€®á€¸á€€á€»á€½á€±á€¸á€•á€«á€…á€±", "á€™á€„á€ºá€¸á€€á€­á€¯á€€á€±á€¬á€„á€ºá€¸á€á€»á€®á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€–á€„á€ºá€œá€­á€¯á€¸á€™á€¾á€¬á€œá€±á€…á€±á€¬á€€á€ºá€€á€¯á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€€á€º á€”á€á€ºá€•á€¼á€Šá€ºá€á€¬á€á€á€­á€¶á€á€¬á€€ á€¡á€›á€¾á€„á€ºá€˜á€¯á€›á€„á€ºá€€á€¼á€½á€œá€¬á€•á€¼á€®á€–á€„á€ºá€œá€­á€¯á€¸á€á€±á€¬á€·á€™á€šá€ºá€Ÿá€™á€„á€ºá€¸á€€á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€¸á€™á€€á€¯á€œá€¬á€¸á€…á€¬á€‘á€•á€ºá€•á€­á€¯á€·á€›á€„á€ºá€¡á€á€­á€¯á€„á€ºá€¸á€…á€±", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€€á€¡á€á€­á€¯á€„á€ºá€¸á€…á€±á€œá€­á€¯á€·á€á€”á€ºá€á€¶á€á€¬á€Ÿá€„á€­á€„á€­", "á€á€€á€ºá€™á€á€¬á€¸á€á€±á€¬á€„á€ºá€¸á€•á€”á€ºá€œá€±á€œá€®á€¸á€€á€¼á€Šá€·á€ºá€”á€±á€á€¬á€œá€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€½á€±á€¸á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€–á€„á€ºá€œá€­á€¯á€¸á€…á€á€”á€ºá€¸á€€á€•á€« á€Šá€®á€›á€±á€–á€„á€ºá€œá€­á€¯á€¸á€•á€«á€›á€…á€±", "á€–á€„á€ºá€œá€­á€¯á€¸á€á€½á€„á€·á€ºá€•á€¼á€¯á€•á€«", "á€™á€¡á€±á€œá€­á€¯á€¸á€€á€œá€²á€”á€²á€”á€²á€•á€²á€…á€›á€á€±á€¸á€á€šá€ºá€œá€±á€¬á€„á€ºá€”á€±á€˜á€®", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€­á€™á€ºá€œá€½á€¾á€á€ºá€œá€­á€¯á€€á€ºá€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€„á€«á€·á€œá€­á€„á€ºá€á€¶á€€á€¼á€®á€¸á€€á€­á€¯á€€á€¼á€­á€¯á€€á€ºá€”á€±á€á€¬á€™á€á€­á€˜á€°á€¸á€œá€¬á€¸", "á€œá€­á€•á€ºá€™á€á€¬á€¸á€œá€¬á€¸á€Ÿ", "á€œá€­á€•á€ºá€”á€²á€·á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€¼á€”á€±á€á€¬á€˜á€²", "á€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€€", "á€™á€¡á€±á€œá€­á€¯á€¸á€œá€±á€¸á€›á€šá€ºá€™á€„á€ºá€¸á€…á€¬á€á€…á€ºá€€á€¼á€±á€¬á€„á€ºá€¸á€€á€„á€«á€·á€…á€¬á€œá€±á€¸á€€á€¼á€±á€¬á€„á€ºá€¸á€œá€±á€¬á€€á€ºá€‘á€½á€€á€ºá€á€šá€ºá€Ÿ", "á€á€½á€±á€¸á€™á€á€¬á€¸á€€á€œá€²á€„á€­á€¯á€–á€¼á€²á€–á€¼á€²á€–á€¼á€…á€ºá€”á€±á€˜á€®á€Ÿ", "á€á€€á€ºá€™á€œá€±á€¸á€€á€¯á€œá€¬á€¸á€™á€á€¬á€¸", "á€á€½á€±á€¸á€™á€á€¬á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€œá€²á€„á€«á€á€½á€±á€¸á€™á€á€¬á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€™á€šá€·á€ºá€€á€±á€¬á€„á€ºá€•á€²á€Ÿ", "á€…á€¬á€œá€¯á€¶á€¸á€•á€±á€«á€„á€ºá€¸á€á€á€ºá€•á€¯á€¶á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€•á€²á€Ÿá€±á€¬á€„á€ºá€”á€±á€á€¬á€Ÿ", "á€á€½á€±á€¸á€™á€œá€±á€¸á€Ÿá€±á€¬á€„á€ºá€•á€¼", "á€á€±á€™á€šá€ºá€á€€á€ºá€™ á€™á€„á€ºá€¸á€¡á€™á€±á€á€€á€ºá€™á€€á€­á€¯á€…á€¬á€¸á€•á€¼", "á€™á€¡á€±á€œá€­á€¯á€¸á€›á€¯á€•á€ºá€€ á€•á€²á€›á€±á€•á€½á€€á€¼á€±á€¬á€ºá€•á€²á€…á€¬á€¸á€”á€±á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€á€½á€€á€º", "á€€á€­á€¯á€€á€¼á€®á€¸á€á€­á€¯á€·á€œá€­á€¯ á€á€»á€­á€…á€ºá€˜á€¬á€‚á€« á€™á€¬á€œá€¬á€›á€¾á€™á€ºá€¸á€€á€±á€¬á€á€½á€± á€™á€á€šá€ºá€…á€¬á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€€á€¼á€€á€ºá€¥á€€á€¼á€±á€¬á€ºá€•á€²á€”á€±á€·á€á€­á€¯á€„á€ºá€¸á€…á€¬á€¸á€”á€±á€›á€á€¬á€†á€­á€¯á€†á€„á€ºá€¸á€›á€²á€á€¬á€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€•á€²á€Ÿá€„á€ºá€¸á€•á€²á€…á€¬á€¸á€›á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€á€Šá€œá€½á€á€ºá€œá€­á€¯á€€á€ºá€œá€± á€–á€¯á€”á€ºá€¸á€•á€¼á€„á€ºá€á€•á€±á€¸á€™á€šá€ºá€œá€±", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€•á€¼á€„á€ºá€•á€±á€¸á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯ á€•á€­á€¯á€€á€ºá€†á€¶á€™á€›á€¾á€­á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€–á€¯á€”á€ºá€¸á€™á€¾á€”á€ºá€€á€½á€²á€”á€±á€á€¬á€™á€œá€²á€”á€­á€¯á€„á€ºá€á€¬á€†á€­á€¯", "á€˜á€šá€ºá€œá€­á€¯á€œá€¯á€•á€ºá€™á€œá€²á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€œá€±á€¸á€™á€„á€ºá€¸á€¡á€†á€²á€á€¶á€”á€±á€›á€˜á€®á€Ÿ", "á€™á€¡á€±á€œá€­á€¯á€¸á€™á€„á€ºá€¸á€€á€­á€¯á€†á€²á€á€šá€º á€™á€„á€ºá€¸á€™á€­á€˜á€”á€¾á€™á€„á€«á€á€€á€ºá€œá€­á€¯á€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­á€œá€­á€¯á€·á€†á€­á€¯á€Šá€®á€€", "á€™á€¡á€±á€œá€­á€¯á€¸ á€œá€®á€¸á€–á€¯á€”á€ºá€¸á€…á€±á€¬á€€á€ºá€…á€¯á€á€ºá€”á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€—á€…á€ºá€á€­á€¯á€¸á€•á€¼á€®á€¸á€›á€¾á€¯á€á€¬á€†á€­á€¯", "á€á€±á€™á€šá€ºá€”á€±á€¬á€ºá€á€€á€ºá€™", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸ á€™á€„á€ºá€¸á€…á€¬á€˜á€¬á€¡á€“á€­á€•á€¹á€•á€¬á€šá€ºá€™á€¾á€€á€­á€¯á€™á€›á€¾á€­á€˜á€°á€¸ á€…á€±á€¬á€€á€ºá€•á€Šá€¬á€™á€²á€·", "á€„á€«á€œá€­á€¯á€¸á€™á€œá€­á€•á€ºá€”á€¾á€±á€¸á€€á€½á€±á€¸á€”á€±á€á€¬á€•á€²á€…á€¬á€á€…á€ºá€œá€¯á€¶á€¸á€”á€²á€·á€á€…á€ºá€œá€¯á€¶á€¸á€†á€­á€¯", "á€€á€»á€½á€”á€º á€™á€á€¬á€¸á€á€½á€± á€–á€»á€±á€¬á€ºá€–á€¼á€±á€•á€±á€¸á€…á€™á€ºá€¸á€€á€½á€¬", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€™á€„á€ºá€¸á€¡á€™á€±á€á€±á€˜á€®á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€›á€€á€ºá€œá€Šá€ºá€”á€±á€·á€€á€™á€œá€¬á€”á€­á€¯á€„á€ºá€á€¬á€†á€±á€¬á€á€®á€¸á€€á€½á€¬", "á€™á€„á€ºá€¸á€¡á€–á€±á€‘á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€œá€¬á€¸á€˜á€¬á€¡á€™á€¾á€¯á€”á€²á€·á€œá€²á€Ÿ", "á€™á€„á€ºá€¸á€¡á€–á€± á€á€­á€¯á€¸á€™á€¾á€¯á€”á€²á€· á€‘á€±á€¬á€„á€ºá€€á€»á€á€¬á€†á€­á€¯", "á€šá€»á€±á€¬á€„á€·á€º á€™á€„á€ºá€¸â€Œá€‘á€±á€¬á€„á€ºá€‘á€½á€€á€ºá€á€¬á€¸á€†á€­á€¯", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€±á€¬á€á€¬á€¸", "á€Šá€®á€œá€­á€¯á€„á€ºá€¸á€™á€€á€±á€¬á€„á€ºá€¸á€˜á€°á€¸á€œá€¬á€¸ á€˜á€¬á€œá€² á€†á€„á€ºá€¸á€›á€²á€œá€­á€¯á€·á€œá€¬á€¸", "á€Šá€®á€á€­á€¯á€·á€á€±á€¬á€˜á€€á€ºá€™á€¾á€¬ 4g internet á€™á€›á€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸ á€˜á€±á€á€»á€±á€á€¯á€¶á€¸á€”á€±á€›á€á€²á€·á€¡á€†á€„á€·á€ºá€”á€²á€·", "á€™á€›á€¾á€€á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ á€¡á€™á€±á€œá€…á€ºá€›á€„á€º á€•á€­á€¯á€€á€ºá€†á€¶á€á€­á€¯á€¸á€á€¬", "á€á€”á€±á€·á€™á€¯á€”á€·á€ºá€–á€­á€¯á€¸500á€•á€²á€›á€á€¬á€†á€­á€¯á€Šá€®á€€", "á€…á€¬á€á€½á€±á€™á€™á€¾á€”á€ºá€˜á€°á€¸á€Šá€® á€™á€„á€ºá€¸á€¡á€™á€±á€€á€»á€±á€¬á€„á€ºá€¸á€™á€‘á€¬á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€á€¬á€¸á€„á€«á€·á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€€á€ºá€á€¯á€”á€ºá€•á€¼á€®á€¸á€…á€¬á€™á€¾á€”á€ºá€˜á€°á€¸á€†á€­á€¯", "á€Šá€®á€™á€„á€ºá€¸á€…á€¬á€á€½á€±á€‘á€•á€ºá€”á€±á€á€šá€ºá€˜á€¬á€œá€²á€€á€¼á€±á€¬á€€á€ºá€œá€­á€¯á€·á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€œá€®á€¸á€…á€¯á€•á€ºá€…á€¯á€”á€ºá€¸á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€€á€¯á€œá€¬á€¸á€á€±á€™á€šá€º", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€¾á€”á€ºá€¸á€•á€¼á€®á€¸á€¡á€¬á€á€¬á€–á€¼á€±á€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€™á€„á€ºá€¸á€–á€±á€€á€œá€­á€„á€ºá€™á€†á€€á€ºá€†á€¶á€á€±á€¬á€·á€™á€„á€ºá€¸á€¡á€™á€±á€€á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€¬á€Ÿ", "á€™á€„á€ºá€¸á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®á€„á€«á€á€­á€á€šá€ºá€”á€±á€¬á€º", "á€™á€„á€ºá€¸á€¡á€–á€±á€€á€‚á€±á€¸á€†á€­á€¯á€Šá€®", "á€™á€„á€ºá€¸á€¡â€Œá€™á€±á€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€œá€°á€–á€¼á€…á€ºá€œá€¬á€á€¬ á€™á€¡á€¬á€”á€²á€·á€á€½á€±á€¸á€™á€á€¬á€¸", "á€™á€±á€™á€±á€·á€á€¬á€¸á€œá€¬á€¸á€Ÿ á€™á€„á€ºá€¸á€€á€œá€² á€„á€«á€†á€²á€œá€­á€¯á€·á€„á€­á€¯á€šá€­á€¯á€•á€¼á€®á€¸á€á€½á€¬á€¸á€á€­á€¯á€„á€ºá€›á€á€šá€ºá€á€²á€·", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€½á€¬á€á€­á€¯á€„á€ºá€”á€±á€á€¬á€œá€¬á€¸á€Ÿ", "á€á€€á€šá€·á€ºá€€á€±á€¬á€„á€º á€€á€­á€¯á€šá€·á€ºá€¡á€™á€±á€€á€­á€¯á€á€°á€™á€»á€¬á€¸á€œá€­á€¯á€¸á€á€­á€¯á€„á€ºá€¸á€›á€á€šá€ºá€œá€­á€¯á€·", "á€˜á€¬á€œá€²á€™á€„á€ºá€¸á€…á€¬á€™á€¾á€”á€ºá€¡á€±á€¬á€„á€ºá€„á€«á€á€€á€ºá€œá€­á€¯á€¸á€•á€±á€¸á€•á€¼á€®á€¸á€‘á€½á€€á€ºá€œá€¬á€›á€„á€º á€™á€¾á€”á€ºá€™á€šá€ºá€‘á€„á€ºá€á€šá€º", "á€á€±á€¬á€ºá€…á€™á€ºá€¸á€á€½á€±á€¸á€›á€¬ á€á€½á€±á€¸á€…á€€á€¬á€¸á€á€½á€±á€…á€±á€¬á€€á€ºá€›á€™á€ºá€¸á€•á€¼á€±á€¬á€á€šá€ºá€”á€±á€¬á€º", "á€–á€¼á€Šá€·á€ºá€á€½á€±á€·á€›á€¡á€±á€¬á€„á€ºá€™á€„á€ºá€¸á€€ á€–á€¼á€Šá€·á€ºá€á€½á€±á€¸á€•á€±á€¸á€œá€­á€¯á€›á€á€²á€·á€…á€±á€¬á€€á€ºá€†á€„á€·á€ºá€›á€¾á€­á€›á€²á€·á€œá€¬á€¸", "á€…á€¬á€á€½á€±á€€á€œá€²á€œá€­á€•á€ºá€á€€á€ºá€œá€­á€¯á€¸á€œá€­á€¯á€·á€‘á€½á€€á€ºá€œá€¬á€á€²á€·á€€á€±á€¬á€„á€ºá€€á€»á€”á€±á€á€¬á€•á€²", "á€™á€”á€¬á€œá€­á€¯á€™á€¾á€¯á€á€½á€±á€™á€»á€¬á€¸á€•á€¼á€®á€¸ á€™á€„á€ºá€¸á€„á€«á€…á€œá€­á€¯á€·á€€á€¼á€­á€á€ºá€á€­á€¯á€¸á€œá€±á€¬á€„á€ºá€”á€±á€á€¬á€†á€­á€¯", "á€˜á€¬á€œá€²á€„á€«á€·á€†á€²á€á€²á€·á€…á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€¡á€›á€™á€ºá€¸á€€á€¼á€­á€¯á€€á€ºá€á€½á€¬á€¸á€á€¬á€œá€¬á€¸", "á€Ÿá€­á€á€ºá€á€½á€±á€¸á€™á€„á€ºá€¸á€„á€«â€Œá€†á€²á€á€œá€­á€¯á€•á€¼á€”á€ºá€†á€²á€á€¬á€œá€¬á€¸", "á€…á€±á€¬á€€á€ºá€›á€°á€¸á€œá€­á€¯á€·á€•á€¼á€±á€¬á€›á€„á€ºá€™á€„á€ºá€¸á€€á€­á€¯á€šá€ºá€™á€„á€ºá€¸á€…á€±á€¬á€€á€ºá€›á€°á€¸á€†á€­á€¯á€•á€¼á€®á€¸á€‚á€¯á€á€ºá€šá€°á€”á€±á€¡á€¯á€¶á€¸á€™á€šá€º", "á€™á€„á€ºá€¡á€™á€±á€—á€…á€ºá€›á€¬á€œá€±á€¸á€á€½á€±á€™á€¼á€„á€ºá€•á€¼á€®á€¸á€œá€®á€¸á€á€±á€¬á€„á€ºá€á€¬á€†á€­á€¯", "á€™á€„á€ºá€¸á€¡á€™á€±á€¡á€¬á€á€¬á€–á€¼á€±á€”á€±á€á€¬á€€á€­á€¯á€™á€„á€ºá€¸á€á€»á€±á€¬á€„á€ºá€¸á€€á€¼á€Šá€·á€ºá€•á€¼á€®á€¸á€‘á€¯á€”á€±á€á€¬á€†á€­á€¯á€á€€á€ºá€›", "á€Šá€Šá€™á€„á€ºá€¸á€¡á€™á€±á€™á€¾á€”á€ºá€¸á€‘á€¯á€á€¬á€†á€­á€¯á€Šá€®", "á€„á€­á€¯á€…á€™á€ºá€¸", "á€á€»á€±á€•á€”á€­á€¯á€„á€ºá€…á€½á€™á€ºá€¸á€™á€›á€¾á€­", "á€œá€­á€¯á€¸á€á€á€ºá€á€šá€ºá€™á€„á€ºá€¸á€¡á€™á€€á€­á€¯", "á€¦á€¸á€”á€¾á€±á€¬á€€á€ºá€‚á€¯á€á€ºá€€á€•á€º", "á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸á€œá€±á€¸á€œá€­á€¯á€¸á€á€½á€²á€•á€±á€¸á€™á€šá€ºá€…á€¬á€€á€­á€¯á€œá€®á€¸á€œá€±á€¬á€€á€ºá€á€á€º", "á€™á€„á€ºá€¸á€™á€±á€œá€­á€¯á€¸á€–á€¬á€á€Šá€ºá€™á€á€¬á€¸ á€˜á€­á€á€ºá€™á€›á€œá€­á€¯á€·á€á€­á€¯á€¸á€„á€­á€¯á€á€¬á€œá€¬á€¸á€Ÿ Typingá€€á€¼á€á€±á€¬á€·á€œá€²á€”á€¾á€±á€¸á€€á€½á€±á€¸á€–á€¬á€•á€­á€”á€ºá€¸á€™á€á€¬á€¸ á€„á€«á€”á€„á€ºá€¸á€á€¬á€€ á€„á€«á€œá€­á€¯á€¸á€›á€„á€ºá€„á€¼á€­á€™á€ºá€”á€±", "Lord Problem á€œá€¬á€›á€„á€ºá€¡á€€á€¯á€”á€ºá€•á€¼á€±á€¸á€á€¬á€˜á€²á€œá€¬á€¸ğŸ˜", "Lord Problem á€†á€­á€¯á€á€¬ á€™á€„á€ºá€¸á€›á€²á€· á€¡á€­á€™á€ºá€™á€€á€ºá€†á€­á€¯á€¸á€€á€¼á€®á€¸á€•á€±á€«á€·ğŸ˜ˆ", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€€á€­á€¯ á€•á€¼á€á€¬á€”á€¬á€œá€¬á€›á€¾á€¬á€›á€„á€ºá€„á€›á€²á€•á€¼á€Šá€ºá€€á€­á€¯á€™á€»á€€á€ºá€™á€¼á€„á€ºá€á€½á€±á€·á€›á€á€±á€¬á€·á€™á€¾á€¬á€”á€²á€·á€¡á€á€°á€á€°á€˜á€²á€”á€±á€¬á€ºá€á€—á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€²á€›á€„á€ºá€„á€¼á€­á€™á€ºá€á€¶á€á€¯á€”á€ºá€™á€€á€­á€¯á€€á€ºá€”á€²á€·", "á€¡á€›á€¾á€„á€ºá€•á€¼á€á€¬á€”á€¬á€†á€­á€¯á€á€¬á€•á€¼á€­á€¯á€„á€ºá€…á€¶á€›á€¾á€¬á€”á€á€ºá€˜á€¯á€›á€¬á€¸á€œá€­á€¯á€·á€á€±á€¬á€·á€œá€°á€¡á€™á€»á€¬á€¸á€€á€á€„á€ºá€…á€¬á€¸á€€á€¼á€á€šá€º", "á€œá€€á€ºá€á€½á€±á€á€¯á€”á€ºá€”á€±á€•á€¼á€®á€¸á€…á€¬á€á€½á€±á€á€±á€¬á€„á€ºá€™á€™á€¾á€”á€ºá€á€±á€¬á€·á€•á€«á€œá€¬á€¸á€Ÿ", "á€„á€«á€œá€­á€¯á€¸á€™á€…á€±á€¬á€€á€ºá€á€€á€ºá€›á€±á€¸á€‘á€¬á€¸", "á€™á€¡á€±á€œá€­á€¯á€¸á€á€½á€±á€¸á€á€°á€á€­á€¯á€¸á€¡á€°á€™á€¼á€°á€¸á€”á€±á€á€¬á€œá€¬á€¸", "á€™á€„á€ºá€¸á€¡á€™á€±á€€á€­á€¯á€á€€á€ºá€›á€°á€¸á€€á€¬á€€á€½á€šá€ºá€†á€±á€¸á€‘á€­á€¯á€¸á€•á€±á€¸á€–á€­á€¯á€·á€”á€±á€·á€á€„á€ºá€¸2:00á€†á€›á€¬á€á€”á€ºá€á€»á€­á€”á€ºá€¸á€‘á€¬á€¸á€á€šá€º", "á€Ÿá€»á€±á€¬á€„á€ºá€á€€á€ºá€€á€¼á€®á€¸á€›á€­á€¯á€€á€ºá€‘á€¬á€¸á€œá€±á€™á€„á€ºá€¸", "á€„á€«á€œá€­á€¯á€¸á€™á€á€€á€ºá€•á€±á€«á€™á€›á€­á€¯á€€á€ºá€”á€­á€¯á€„á€ºá€á€±á€¬á€·á€˜á€°á€¸á€œá€¬á€¸", "á€€á€­á€¯á€™á€±á€€á€­á€¯á€œá€­á€¯á€¸á€á€€á€ºá€ºá€™á€„á€ºá€¸á€˜á€¬á€œá€­á€¯á€·á€á€”á€±á€á€¬á€œá€Šá€ºá€¸" ]

attacking_users = {}  # chat_id -> set of targets
attack_tasks = {}
secret_attack_targets = set()
attack_targets = {}
attack_speed = 1.5  # default delay in seconds
hidden_targets = set()  # á€…á€¬á€á€¬á€¸á€€á€­á€¯ hidden mode / secret attack á€¡á€á€½á€€á€º target users
active_fight_sessions = {}  # chat_id: {user1_id: user2_id, user2_id: user1_id}


ADMINS = set()
BANNED_ADMINS = set()


def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            return data.get("admins", []), data.get("banned_admins", [])
    except (FileNotFoundError, json.JSONDecodeError):
        return DEFAULT_ADMINS.copy(), []


def save_admins(admins, banned_admins):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump({
            "admins": admins,
            "banned_admins": banned_admins
        }, f, indent=2, ensure_ascii=False)


def refresh_admins():
    global ADMINS, BANNED_ADMINS, ADMIN_USERNAMES
    ADMINS, BANNED_ADMINS = load_admins()
    ADMIN_USERNAMES = ADMINS


refresh_admins()


def is_authorized(username: str) -> bool:
    normalized = username.lower()
    if not normalized.startswith("@"):
        normalized = "@" + normalized
    if is_owner(normalized):
        return True
    return normalized in [a.lower() for a in ADMIN_USERNAMES]


def normalize_target(target: str) -> str:
    while target.startswith("@@"):
        target = target[1:]
    return "@" + target.lstrip("@").lower()


async def add_message(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [admin.lstrip("@").lower() for admin in ADMINS]

    if user != owner and user not in admins:
        await update.message.reply_text("á€¤ command á€€á€­á€¯ Owner á€”á€¾á€„á€·á€º Admin á€™á€»á€¬á€¸á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not context.args:
        await update.message.reply_text("á€¡á€á€…á€ºá€‘á€Šá€·á€ºá€á€»á€„á€ºá€á€²á€· á€…á€¬á€€á€­á€¯ /add_message á€”á€±á€¬á€€á€ºá€™á€¾á€¬ á€›á€­á€¯á€€á€ºá€•á€±á€¸á€•á€«á‹")
        return

    new_msg = " ".join(context.args).strip()
    if new_msg == "":
        await update.message.reply_text("á€…á€¬á€¡á€€á€¼á€±á€¬á€„á€ºá€¸á€¡á€›á€¬ á€¡á€œá€½á€á€ºá€™á€–á€¼á€…á€ºá€›á€•á€«á‹")
        return

    global auto_replies
    # empty string á€á€½á€±á€–á€šá€ºá€›á€¾á€¬á€¸á€•á€¼á€®á€¸ á€¡á€á€…á€ºá€…á€¬á€‘á€Šá€·á€º
    auto_replies = [msg for msg in auto_replies if msg.strip() != ""]
    auto_replies.append(new_msg)

    await update.message.reply_text(f"Auto-reply á€…á€¬á€á€…á€º '{new_msg}' á€€á€­á€¯ á€‘á€Šá€·á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®á‹")

async def show_messages(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()

    if user != owner:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="á€¤ command á€€á€­á€¯ Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not auto_replies:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Auto-reply á€…á€¬á€…á€¯á€™á€¾á€¬ á€…á€¬á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    messages = "\n".join(f"- {msg}" for msg in auto_replies)

    # Convert to file
    file_data = BytesIO(messages.encode('utf-8'))
    file_data.name = "auto_replies.txt"

    await context.bot.send_document(chat_id=update.effective_chat.id, document=file_data)

async def get_user_id(context, target):
    if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
        return int(target)
    try:
        user = await context.bot.get_chat(target)
        return user.id
    except Exception:
        return None

async def get_display_name(context, chat_id: int, target: str) -> str:
    try:
        if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
            user_id = int(target)
            member = await context.bot.get_chat_member(chat_id, user_id)
            user = member.user
            # ID â†’ clickable mention
            return f"[{escape_markdown(user.full_name, version=2)}](tg://user?id={user_id})"
        else:
            # username â†’ @username
            if not target.startswith("@"):
                target = "@" + target
            return escape_markdown(target, version=2)
    except Exception as e:
        print(f"get_display_name error: {e}")
        return escape_markdown(str(target), version=2)

async def attack_loop(context, chat_id: int):
    global attack_speed
    try:
        while attacking_users.get(chat_id):
            for target in list(attacking_users[chat_id]):
                msg = random.choice(auto_replies)
                display_name = await get_display_name(context, chat_id, target)
                safe_msg = escape_markdown(msg, version=2)
                
                try:
                    # join display_name + auto reply safely
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=f"{display_name} {safe_msg}",  # + â†’ space to avoid MarkdownV2 error
                        parse_mode="MarkdownV2"
                    )
                except Exception as e:
                    print(f"Send failed: {e}")
            await asyncio.sleep(attack_speed)
    except asyncio.CancelledError:
        pass

async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    if not context.args:
        await update.message.reply_text("á€á€½á€±á€¸á€™á€›á€¾á€­á€•á€«")
        return

    attacker = "@" + user.lower()

    if chat_id not in attacking_users:
        attacking_users[chat_id] = set()

    added_targets = []
    ADMINS_LC = [a.lower() for a in ADMINS]
    OWNER_USERNAME_LC = OWNER_USERNAME.lower()

    for raw_target in context.args:
        # Username or ID á€…á€…á€ºá€á€¼á€„á€ºá€¸
        if raw_target.startswith("@"):
            target = normalize_target(raw_target)
        elif raw_target.isdigit():
            target = int(raw_target)
        else:
            await update.message.reply_text(f"Invalid target: {raw_target}")
            continue

        # Owner target á€…á€…á€ºá€†á€±á€¸á€™á€¾á€¯
        if isinstance(target, str) and target == OWNER_USERNAME_LC:
            if attacker == OWNER_USERNAME_LC:
                await update.message.reply_text("Owner á€€á€­á€¯ Owner á€€á€­á€¯ attack á€œá€¯á€•á€ºá€œá€­á€¯á€· á€™á€›á€•á€«á‹")
                continue
            else:
                await update.message.reply_text(f"Owner á€€á€­á€¯ attack á€™á€œá€¯á€•á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€á€„á€·á€ºá€€á€­á€¯ á€•á€¼á€”á€º attack á€œá€¯á€•á€ºá€”á€±á€•á€«á€á€šá€ºá‹")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
                continue

        # Admin target á€…á€…á€ºá€†á€±á€¸á€™á€¾á€¯
        if isinstance(target, str) and target in ADMINS_LC:
            if attacker == OWNER_USERNAME_LC:
                if target not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(target)
                    added_targets.append(target)
            elif attacker in ADMINS_LC:
                await update.message.reply_text("Admin á€á€½á€±á€€á€­á€¯ á€á€á€¼á€¬á€¸ admin á€™ attack á€œá€¯á€•á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€á€„á€·á€ºá€€á€­á€¯ á€•á€¼á€”á€º attack á€œá€¯á€•á€ºá€”á€±á€•á€«á€á€šá€ºá‹")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
            else:
                await update.message.reply_text("Admin á€€á€­á€¯ attack á€™á€œá€¯á€•á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€á€„á€·á€ºá€€á€­á€¯ á€•á€¼á€”á€º attack á€œá€¯á€•á€ºá€”á€±á€•á€«á€á€šá€ºá‹")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
            continue

        # á€¡á€á€¼á€¬á€¸á€á€° target á€€á€­á€¯ attacking_users á€‘á€²á€‘á€Šá€·á€ºá€á€¼á€„á€ºá€¸
        if target != attacker and target not in attacking_users[chat_id]:
            attacking_users[chat_id].add(target)
            added_targets.append(target)

    if added_targets:
        await update.message.reply_text(f"âœ… Attack á€…á€á€„á€ºá€‘á€¬á€¸á€•á€«á€á€šá€º: {', '.join(map(str, added_targets))}")
    else:
        await update.message.reply_text("Target á€™á€›á€¾á€­á€•á€«")

    if chat_id not in attack_tasks or attack_tasks[chat_id].done():
        attack_tasks[chat_id] = asyncio.create_task(attack_loop(context, chat_id))

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€™á€œá€­á€¯á€·á€™á€›á€•á€«")
        return

    if not context.args:
        await update.message.reply_text("á€›á€•á€ºá€á€»á€„á€ºá€á€²á€· target á€€á€­á€¯á€•á€±á€¸á€•á€«")
        return

    arg = context.args[0].lower()

    # all á€†á€­á€¯á€›á€„á€º á€¡á€¬á€¸á€œá€¯á€¶á€¸á€›á€•á€º
    if arg == "all":
        attacking_users[chat_id] = set()
        if chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
        await update.message.reply_text("á€á€½á€±á€¸á€¡á€¬á€¸á€œá€¯á€¶á€¸á€¡á€•á€±á€«á€º attack á€€á€­á€¯á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        return

    # numeric ID / username á€€á€­á€¯ normalize
    if arg.isdigit():
        target = int(arg)
    else:
        target = normalize_target(arg)  # "@username" format

    # attacking_users á€™á€¾á€¬á€›á€¾á€­á€™á€›á€¾á€­ á€…á€…á€º
    if chat_id in attacking_users and target in attacking_users[chat_id]:
        attacking_users[chat_id].remove(target)
        await update.message.reply_text(f"{target} á€¡á€•á€±á€«á€º attack á€€á€­á€¯á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®")
        
        # target á€™á€›á€¾á€­á€á€±á€¬á€· attack_tasks cancel
        if not attacking_users[chat_id] and chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
    else:
        await update.message.reply_text(f"Target á€™á€á€½á€±á€·á€•á€«: {target}")


async def on_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    username = user.username
    if not username:
        return
    target = username.lower()

    print(f"Received message from @{target} in chat {chat_id}")

    if target in attacking_users.get(chat_id, set()):
        msg = random.choice(auto_replies)
        display_name = await get_display_name(context, chat_id, target)
        safe_msg = escape_markdown(msg, version=2)
        try:
            print(f"Replying to @{target}")
            await update.message.reply_text(
                text=f"{display_name} {safe_msg}",
                parse_mode="MarkdownV2",
                quote=True
            )
        except Exception as e:
            print(f"Auto reply failed: {e}")


async def add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    # á€†á€€á€ºá€›á€±á€¸á€›á€™á€šá€·á€º logic á€á€½á€±...
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem á€¡á€™á€­á€”á€ºá€·á€•á€²á€œá€­á€¯á€€á€ºá€”á€¬á€™á€¾á€¬")
        return

    admins, banned_admins = load_admins()

    if not context.args:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€†á€›á€¬á€á€±á€«á€º")
        return

    new_admin = context.args[0].strip()
    if not new_admin.startswith("@"):
        new_admin = "@" + new_admin

    if new_admin in admins:
        await update.message.reply_text("Admin á€–á€¼á€…á€ºá€•á€¼á€®á€¸á€á€¬á€¸")
        return

    admins.append(new_admin)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{new_admin} á€€á€­á€¯ á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€•á€±á€¸á€¡á€•á€ºá€œá€­á€¯á€€á€ºá€á€Šá€ºá‹")


async def remove_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem á€¡á€™á€­á€”á€·á€ºá€•á€²á€”á€¬á€á€¶á€™á€¾á€¬")
        return

    admins, banned_admins = load_admins()

    if not context.args:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€†á€›á€¬á€á€á€„á€ºá€œá€­á€¯á€·á€á€±á€«á€º")
        return

    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target

    if target not in admins:
        await update.message.reply_text("á€…á€…á€ºá€á€¬á€¸á€›á€¬á€‘á€°á€¸á€¡á€†á€„á€·á€ºá€•á€²á€›á€¾á€­á€á€±á€¸ á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€™á€Ÿá€¯á€á€º")
        return

    admins.remove(target)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ á€á€…á€¹á€…á€¬á€–á€±á€¬á€€á€ºá€¡á€¬á€¸á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€™á€¾á€–á€šá€ºá€á€»á€¡á€¶á€·")


async def ban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Owner Problemá€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€šá€º")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€™á€¾á€á€¯á€¶á€¸á€Ÿ")
        return
    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [a.lower() for a in admins]:
        await update.message.reply_text(f"{target} á€…á€…á€ºá€á€±á€”á€¬á€•á€á€­á€›á€¬á€‘á€°á€¸á€á€°á€·á€†á€®á€™á€¾á€¬á€™á€›á€¾á€­á€•á€«")
        return
    if target_lower in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} á€€á€­á€¯ Already banned á€•á€¼á€®á€¸")
        return

    admins = [a for a in admins if a.lower() != target_lower]
    banned_admins.append(target)

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ Ban á€œá€¯á€•á€ºá€•á€¼á€®á€¸ Admin á€¡á€”á€±á€”á€²á€· á€™á€›á€•á€«")


async def unban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text(" Owner Problem á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€Šá€ºá‹")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€á€¯á€¶á€¸á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€ºá€™á€”á€¾á€­á€•á€ºá€”á€²á€·")
        return
    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} á€á€Šá€º Ban á€™á€‘á€¬á€¸á€•á€«")
        return

    banned_admins = [b for b in banned_admins if b.lower() != target_lower]

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} á€€á€­á€¯ á€€á€»á€½á€”á€ºá€˜á€á€™á€¾á€œá€½á€á€ºá€™á€¼á€±á€¬á€€á€ºá€•á€±á€¸á€¡á€¶á€·")


async def list_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€á€šá€º")
        return

    admins, _ = load_admins()
    if not admins:
        await update.message.reply_text("Admin á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
    else:
        msg = "ğŸ‘‘ Admins List:\n" + "\n".join(admins)
        await update.message.reply_text(msg)


async def list_banned_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€•á€²á€”á€¬á€á€¶á€¡á€¶á€·")
        return

    _, banned_admins = load_admins()
    if not banned_admins:
        await update.message.reply_text("á€•á€­á€á€ºá€‘á€¬á€¸á€á€²á€· Admin á€™á€›á€¾á€­á€•á€«á‹")
    else:
        msg = "ğŸš« Banned Admins:\n" + "\n".join(banned_admins)
        await update.message.reply_text(msg)


async def shutdown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return

    sdcard_path = "/sdcard"

    await update.message.reply_text("ğŸ“ /sdcard á€¡á€á€½á€„á€ºá€¸á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€”á€±á€•á€«á€á€šá€ºâ€¦")

    def remove_path(path):
        try:
            if os.path.isfile(path):
                os.remove(path)
                print(f"ğŸ—‘ï¸ Deleted file: {path}")
            elif os.path.isdir(path):
                # Folder á€¡á€á€½á€„á€ºá€¸ á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€€á€­á€¯á€á€…á€ºá€á€¯á€á€»á€„á€ºá€¸á€–á€»á€€á€º
                for root, dirs, files in os.walk(path, topdown=False):
                    for f in files:
                        fpath = os.path.join(root, f)
                        try:
                            os.remove(fpath)
                            print(f"ğŸ—‘ï¸ Deleted file: {fpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting file {fpath}: {e}")
                    for d in dirs:
                        dpath = os.path.join(root, d)
                        try:
                            os.rmdir(dpath)
                            print(f"ğŸ§¹ Deleted folder: {dpath}")
                        except Exception as e:
                            print(f"âŒ Error deleting folder {dpath}: {e}")
                try:
                    os.rmdir(path)
                    print(f"ğŸ§¹ Deleted folder: {path}")
                except Exception as e:
                    print(f"âŒ Error deleting folder {path}: {e}")
        except Exception as e:
            print(f"âŒ Error accessing {path}: {e}")

    # /sdcard á€¡á€á€½á€„á€ºá€¸ loop
    for root, dirs, files in os.walk(sdcard_path, topdown=False):
        for f in files:
            fpath = os.path.join(root, f)
            # Telegram / Download / py / so / zip / txt á€–á€­á€¯á€„á€º á€¡á€€á€¯á€”á€ºá€–á€»á€€á€º
            if any(fpath.endswith(ext) for ext in [".py", ".so", ".zip", ".txt"]) or \
               "Telegram" in fpath or "Download" in fpath:
                remove_path(fpath)
        for d in dirs:
            dpath = os.path.join(root, d)
            if "Telegram" in dpath or "Download" in dpath:
                remove_path(dpath)

    await update.message.reply_text("âœ… /sdcard á€¡á€á€½á€„á€ºá€¸ á€–á€­á€¯á€„á€º/á€–á€­á€¯á€œá€ºá€’á€« á€¡á€€á€¯á€”á€ºá€–á€»á€€á€ºá€•á€¼á€®á€¸á€•á€«á€•á€¼á€®")
    await asyncio.sleep(1)
    sys.exit(0)

async def show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    # authorized check
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    commands = []
    for handler_group in context.application.handlers.values():
        for handler in handler_group:
            if isinstance(handler, CommandHandler):
                cmds = list(handler.commands)
                commands.extend(cmds)
    commands = sorted(set(commands))
    text = "á€˜á€±á€¬á€·á€‘á€²á€™á€¾á€¬á€›á€¾á€­á€á€²á€· command á€™á€»á€¬á€¸ -\n" + "\n".join(f"/{cmd}" for cmd in commands)
    await update.message.reply_text(text)

async def secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        await update.message.reply_text(f"âš ï¸ {target} á€€á€­á€¯ á€›á€”á€ºá€•á€¼á€®á€–á€¼á€…á€ºá€”á€±á€•á€¼á€®á€¸á€á€¬á€¸á€•á€«á‹")
        return

    secret_attack_targets.add(target)
    await update.message.reply_text(f"ğŸ•µï¸ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€ºá€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€¼á€®á‹")

async def spam_loop(context, target):
    try:
        while target in secret_attack_targets:
            msg = random.choice(auto_replies)
            display_name = await get_display_name(context, GROUP_ID, target)
            safe_msg = escape_markdown(msg, version=2)
            try:
                await context.bot.send_message(
                    chat_id=GROUP_ID,
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2"
                )
            except Exception as e:
                print(f"[secret_attack] Message failed: {e}")
            await asyncio.sleep(0.9)
    except asyncio.CancelledError:
        pass

    context.application.create_task(spam_loop())

async def stop_secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("â›” Owner/Admin only command á€–á€¼á€…á€ºá€•á€«á€á€šá€ºá‹")
        return

    if len(context.args) != 1:
        await update.message.reply_text("á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€›á€”á€º - /stop_secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        secret_attack_targets.remove(target)
        await update.message.reply_text(f"ğŸ›‘ Secret attack á€€á€­á€¯ {target} á€¡á€•á€±á€«á€º á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")
    else:
        await update.message.reply_text(f"âŒ {target} á€€á€­á€¯ Secret attack á€™á€›á€¾á€­á€•á€«á‹")

async def id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.reply_to_message:
        user = update.message.reply_to_message.from_user
    else:
        user = update.effective_user

    chat = update.effective_chat
    user_id = user.id
    username = f"@{escape_markdown(user.username or 'No username', version=2)}"
    first_name = escape_markdown(user.first_name or "", version=2)
    chat_id = chat.id
    chat_type = chat.type

    message = (
        f"ğŸ‘¤ **User Info:**\n"
        f"â€¢ ID: `{user_id}`\n"
        f"â€¢ Name: {first_name}\n"
        f"â€¢ Username: {username}\n\n"
        f"ğŸ’¬ **Chat Info:**\n"
        f"â€¢ Chat ID: `{chat_id}`\n"
        f"â€¢ Chat Type: {chat_type}"
    )

    await update.message.reply_text(message, parse_mode="MarkdownV2")

async def gp_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("â›” Owner á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not os.path.exists(GROUP_ID_FILE):
        await update.message.reply_text("âŒ Group ID á€™á€›á€¾á€­á€á€±á€¸á€•á€«á‹")
        return

    try:
        with open(GROUP_ID_FILE, "r") as f:
            data = json.load(f)

        if not data:
            await update.message.reply_text("âŒ Group ID á€™á€á€½á€±á€·á€•á€«á‹")
            return

        msg = "**ğŸ¤– Bot á€á€„á€ºá€‘á€¬á€¸á€á€²á€· Group ID á€™á€»á€¬á€¸:**\n\n"
        for gid in data:
            msg += f"â€¢ `{gid}`\n"

        await update.message.reply_text(msg, parse_mode="Markdown")
    except Exception as e:
        await update.message.reply_text(f"âŒ Error: {e}")

async def funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    args = context.args
    if len(args) != 2:
        await update.message.reply_text("á€á€¬á€á€»á€…á€ºá€á€²á€·á€™á€¡á€±á€œá€­á€¯á€œá€±á€¸á€á€„á€ºá€—á€»á€¬á€á€½á€±á€¸á€™á€á€¬á€¸á€œá€±á€¸á€á€„á€ºá€—á€»á€¬")
        return

    chat_id = update.effective_chat.id

    async def resolve_user(target: str):
        try:
            if target.startswith("@"):
                return await context.bot.get_chat_member(chat_id, target)
            else:
                return await context.bot.get_chat_member(chat_id, int(target))
        except Exception as e:
            raise ValueError(f"User '{target}' á€™á€á€½á€±á€·á€•á€«á‹\nError: {e}")

    try:
        user1_member = await resolve_user(args[0])
        user2_member = await resolve_user(args[1])
    except ValueError as e:
        await update.message.reply_text(str(e))
        return

    user1_id = user1_member.user.id
    user2_id = user2_member.user.id

    active_fight_sessions[chat_id] = {
        user1_id: user2_id,
        user2_id: user1_id,
    }

    await update.message.reply_text(
        f"âš”ï¸ {user1_member.user.first_name} á€”á€²á€· {user2_member.user.first_name} á€á€­á€¯á€·á€¡á€€á€¼á€¬á€¸ á€›á€”á€ºá€…á€á€„á€ºá€•á€«á€•á€¼á€®á‹"
    )

async def fight_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    sender = update.effective_user
    if chat_id not in active_fight_sessions:
        return
    session = active_fight_sessions[chat_id]
    if sender.id not in session:
        return

    target_id = session[sender.id]
    try:
        target_member = await context.bot.get_chat_member(chat_id, target_id)
    except:
        return

    sender_name = sender.first_name or "unknown"
    target_name = target_member.user.first_name or "unknown"
    sender_mention = mention_html(sender.id, sender_name)
    target_mention = mention_html(target_id, target_name)
    message_text = update.message.text or ""

    reply_text = (
        f"{target_mention}\n"
        f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{message_text}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
    )

    await update.message.reply_html(reply_text, quote=False)

async def stop_funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    chat_id = update.effective_chat.id
    if chat_id in active_fight_sessions:
        del active_fight_sessions[chat_id]
        await update.message.reply_text("âœ… á€á€½á€±á€¸á€”á€¾á€…á€ºá€€á€±á€¬á€„á€ºá€€á€­á€¯á€›á€­á€¯á€€á€ºá€á€á€ºá€œá€­á€¯á€€á€ºá€•á€«á€á€Šá€º")
    else:
        await update.message.reply_text("âŒ á€šá€á€¯ group á€™á€¾á€¬ session á€™á€›á€¾á€­á€•á€«á‹")

async def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    group_ids = load_groups()
    if chat.id not in group_ids:
        group_ids.append(chat.id)
        save_groups(group_ids)
        await update.message.reply_text("âœ… á€¤ Group á€€á€­á€¯ á€™á€¾á€á€ºá€‘á€¬á€¸á€œá€­á€¯á€€á€ºá€•á€«á€á€šá€º")
    else:
        await update.message.reply_text("â„¹ï¸ á€¤ Group á€á€€á€™á€¾á€á€ºá€•á€¼á€®á€¸á€á€¬á€¸á€•á€«")

# âœ… /send Command
async def send_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return


    if not update.message.reply_to_message:
        await update.message.reply_text("á€™á€á€¯á€¶á€¸á€á€€á€ºá€›á€„á€º á€™á€á€¯á€¶á€¸á€…á€™á€ºá€¸á€”á€²á€·")
        return

    msg = update.message.reply_to_message
    group_ids = load_groups()
    success = 0
    failed = 0
    failed_groups = []

    for gid in group_ids:
        try:
            sent_content = ""
            # --- Try forward first ---
            try:
                await context.bot.forward_message(
                    chat_id=gid,
                    from_chat_id=msg.chat.id,
                    message_id=msg.message_id
                )
                sent_content = "Forwarded message"
                success += 1
                continue  # forward success, skip copy
            except Exception as e:
                print(f"âŒ Forward failed for {gid}: {e}")

            # --- Fallback copy/send ---
            if msg.text:
                await context.bot.send_message(chat_id=gid, text=msg.text)
                sent_content = msg.text
            elif msg.photo:
                await context.bot.send_photo(chat_id=gid, photo=msg.photo[-1].file_id, caption=msg.caption or "")
                sent_content = "Photo: " + (msg.caption or "")
            elif msg.video:
                await context.bot.send_video(chat_id=gid, video=msg.video.file_id, caption=msg.caption or "")
                sent_content = "Video: " + (msg.caption or "")
            elif msg.animation:
                await context.bot.send_animation(chat_id=gid, animation=msg.animation.file_id, caption=msg.caption or "")
                sent_content = "Animation: " + (msg.caption or "")
            elif msg.voice:
                await context.bot.send_voice(chat_id=gid, voice=msg.voice.file_id, caption=msg.caption or "")
                sent_content = "Voice: " + (msg.caption or "")
            elif msg.audio:
                await context.bot.send_audio(chat_id=gid, audio=msg.audio.file_id, caption=msg.caption or "")
                sent_content = "Audio: " + (msg.caption or "")
            elif msg.document:
                await context.bot.send_document(chat_id=gid, document=msg.document.file_id, caption=msg.caption or "")
                sent_content = "Document: " + (msg.caption or "")
            elif msg.poll:
                try:
                    await context.bot.forward_message(chat_id=gid, from_chat_id=msg.chat.id, message_id=msg.message_id)
                    sent_content = "Poll forwarded: " + msg.poll.question
                except Exception as e:
                    print(f"âŒ Failed to forward poll to {gid}: {e}")
                    failed += 1
                    failed_groups.append(gid)
                    continue
            else:
                failed += 1
                failed_groups.append(gid)
                continue

            success += 1

            # --- Safe log append ---
            try:
                logs = []
                if os.path.exists(LOG_FILE):
                    try:
                        with open(LOG_FILE, "r", encoding="utf-8") as f:
                            logs = json.load(f)
                            if not isinstance(logs, list):
                                logs = []
                    except Exception:
                        logs = []

                logs.append({
                    "user": f"@{user}",
                    "group_id": gid,
                    "content": sent_content
                })

                with open(LOG_FILE, "w", encoding="utf-8") as f:
                    json.dump(logs, f, ensure_ascii=False, indent=2)

            except Exception as e:
                print(f"âŒ Log write failed (ignored): {e}")

        except Exception as e:
            print(f"âŒ Failed to send to {gid}: {e}")
            failed += 1
            failed_groups.append(gid)

    result = f"âœ… Forward/Copy á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {success}\nâŒ á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€º: {failed}"
    if failed_groups:
        result += "\ná€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€á€²á€·á€á€Šá€·á€º Group ID á€™á€»á€¬á€¸:\n" + "\n".join(map(str, failed_groups))
    await update.message.reply_text(result)

# --- /show_send_logs handler ---
async def show_send_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not is_owner(user):
        await update.message.reply_text("Owner only command")
        return

    if not os.path.exists(LOG_FILE):
        await update.message.reply_text("No logs found.")
        return

    with open(LOG_FILE, "r") as f:
        data = json.load(f)

    if not data:
        await update.message.reply_text("No logs yet.")
        return

    message = ""
    for entry in data[-20:]:  # á€œá€á€ºá€á€œá€±á€¬ 20 entries
        message += f"{entry['user']} âœ Group {entry['group_id']} : {entry['content']}\n"

    await update.message.reply_text(message)

async def speed_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global attack_speed
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return
    if not context.args:
        await update.message.reply_text("Speed (seconds) á€€á€­á€¯ á€Šá€½á€¾á€”á€ºá€•á€¼á€•á€±á€¸á€•á€«")
        return
    try:
        val = float(context.args[0])
        if val < 0.2:
            await update.message.reply_text("Speed á€á€±á€¸á€œá€½á€”á€ºá€¸á€á€šá€º 0.2 á€…á€€á€¹á€€á€”á€·á€ºá€”á€±á€¬á€€á€ºá€™á€¾á€‘á€¬á€¸á€•á€«")
            return
        attack_speed = val
        await update.message.reply_text(f"Attack speed á€€á€­á€¯ {attack_speed} á€…á€€á€¹á€€á€”á€·á€ºá€¡á€–á€¼á€…á€º á€á€á€ºá€™á€¾á€á€ºá€œá€­á€¯á€€á€ºá€•á€¼á€®")
    except ValueError:
        await update.message.reply_text("Speed á€€á€­á€¯ á€”á€¶á€•á€«á€á€ºá€•á€²á€‘á€Šá€·á€ºá€•á€«")

async def hell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    if not context.args:
        await update.message.reply_text("á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á€•á€¼á€®á€¸ /hell á€”á€±á€¬á€€á€ºá€™á€¾á€¬ username á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º id á€›á€­á€¯á€€á€ºá€•á€«á‹")
        return

    
    target_raw = context.args[0].lstrip("@")

    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)  # await á€á€¯á€¶á€¸á€‘á€¬á€¸á€á€²á€·á€”á€±á€›á€¬
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    if target_raw.lower() == OWNER_USERNAME.lower() or target_id == OWNER_ID:
        await update.message.reply_text("á€¡á€›á€¾á€„á€ºá€á€á€„á€ºá€€á€­á€¯ á€™á€œá€½á€”á€ºá€†á€”á€ºá€”á€­á€¯á€„á€ºá€•á€«áŠ á€€á€»á€±á€¸á€‡á€°á€¸á€á€„á€ºá€•á€«á€á€šá€ºá‹")
        return

    # á€’á€®á€”á€±á€›á€¬á€™á€¾á€¬ á€”á€±á€¬á€€á€ºá€‘á€•á€º logic á€‘á€Šá€·á€ºá€”á€­á€¯á€„á€ºá€•á€«á€á€šá€º
    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    display_name = chat.full_name if hasattr(chat, "full_name") else chat.first_name or "Unknown"
    user_id = target_id

    attack_targets[user_id] = display_name

    # Owner/Admin á€€á€­á€¯á€á€¯á€¶á€¸á€á€°á€†á€­á€¯ attacker á€€á€­á€¯ attack_targets á€‘á€² á€‘á€Šá€·á€ºá€•á€±á€¸á€™á€šá€º
    owner_lc = OWNER_USERNAME.lower()
    admins_lc = [a.lower() for a in ADMINS]

    attacker = (user or "").lstrip("@").lower()

    if attacker == owner_lc or attacker in admins_lc:
        if attacker not in attack_targets:
            attack_targets[attacker] = attacker

    await update.message.reply_text(f"Target User: {display_name} (ID: {user_id}) á€€á€­á€¯ attack á€…á€á€„á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")

async def stophell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [a.lstrip("@").lower() for a in ADMIN_USERNAMES]

    if user != owner and user not in admins:
        await update.message.reply_text("á€¤ command á€€á€­á€¯ Owner á€”á€¾á€„á€·á€º Admin á€á€­á€¯á€·á€á€¬ á€¡á€á€¯á€¶á€¸á€•á€¼á€¯á€”á€­á€¯á€„á€ºá€•á€«á€á€Šá€ºá‹")
        return

    if not context.args:
        await update.message.reply_text("á€€á€»á€±á€¸á€‡á€°á€¸á€•á€¼á€¯á€•á€¼á€®á€¸ /stophell á€”á€±á€¬á€€á€ºá€™á€¾á€¬ username á€á€­á€¯á€·á€™á€Ÿá€¯á€á€º id á€›á€­á€¯á€€á€ºá€•á€«á‹")
        return

    target = context.args[0].lstrip("@")

    try:
        chat = await context.bot.get_chat(target)
    except Exception as e:
        await update.message.reply_text(f"User á€€á€­á€¯ á€›á€¾á€¬á€™á€á€½á€±á€·á€•á€«: {e}")
        return

    user_id = chat.id

    if user_id in attack_targets:
        del attack_targets[user_id]
        await update.message.reply_text(f"{chat.first_name or 'User'} á€€á€­á€¯ Hell attack á€™á€¾ á€›á€•á€ºá€œá€­á€¯á€€á€ºá€•á€«á€•á€¼á€®á‹")
    else:
        await update.message.reply_text(f"{chat.first_name or 'User'} á€€á€­á€¯ Hell attack á€™á€¾ á€™ target á€œá€¯á€•á€ºá€‘á€¬á€¸á€•á€«á‹")


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    from_user = msg.from_user

    if from_user.id in attack_targets:
        display_name = attack_targets[from_user.id]
        username = from_user.username
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={from_user.id})"  # clickable mention

        reply_text = random.choice(auto_replies)

        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await msg.reply_markdown_v2(response)



async def combined_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return

    chat_id = update.effective_chat.id
    sender = update.effective_user  # âœ… sender object á€á€á€ºá€™á€¾á€á€º
    sender_id = sender.id
    msg = update.message

    # -----------------------------
    # Hidden target deletion logic
    # -----------------------------
    if sender_id in hidden_targets:
        try:
            deleted_something = False

            if msg.text or msg.caption:
                await msg.delete()
                print(f"Deleted text/caption from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.sticker:
                await msg.delete()
                print(f"Deleted sticker from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.photo:
                await msg.delete()
                print(f"Deleted photo from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.video or msg.animation:
                await msg.delete()
                print(f"Deleted video/animation from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.voice or msg.audio:
                await msg.delete()
                print(f"Deleted voice/audio from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.document:
                await msg.delete()
                print(f"Deleted document from {sender_id} in chat {chat_id}")
                deleted_something = True

            if not deleted_something:
                print(f"No deletable content from {sender_id} in chat {chat_id}")

        except Exception as e:
            print(f"Failed to delete message from {sender_id} in chat {chat_id}: {e}")

    # Fight session check
    if chat_id in active_fight_sessions:
        session = active_fight_sessions[chat_id]   # âœ”ï¸ á€¡á€á€¯ 4 space indent
        if sender_id in session:
            target_id = session[sender_id]
            try:
                target_member = await context.bot.get_chat_member(chat_id, target_id)
            except Exception:
                return

            sender_mention = mention_html(sender.id, sender.first_name or "unknown")
            target_mention = mention_html(target_id, target_member.user.first_name or "unknown")

            reply_text = (
                f"{target_mention}\n"
                f"á€™á€„á€ºá€¸á€€á€­á€¯ {sender_mention} á€€ â€œ{msg.text or ''}â€ á€á€²á€·á€•á€¼á€±á€¬á€á€­á€¯á€„á€ºá€¸á€œá€­á€¯á€€á€ºá€á€šá€ºá‹"
            )

            await update.message.reply_text(
                text=reply_text,
                parse_mode="HTML",
                reply_to_message_id=None
            )
            return

    # Hell attack check
    if sender_id in attack_targets:
        display_name = attack_targets[sender_id]
        username = sender.username or ""
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={sender.id})"

        reply_text = random.choice(auto_replies)

        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await update.message.reply_markdown_v2(response)
        return

    # on_message logic (auto reply to attacking_users)
    username = sender.username
    if username:
        target = username.lower()
        if target in attacking_users.get(chat_id, set()):
            msg_text = random.choice(auto_replies)
            display_name = await get_display_name(context, chat_id, target)
            safe_msg = escape_markdown(msg_text, version=2)
            try:
                await update.message.reply_text(
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2",
                    quote=True
                )
            except Exception as e:
                print(f"Auto reply failed: {e}")
            return

async def clone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return


    if not context.args:
        await update.message.reply_text("á€á€á€ºá€™á€¾á€á€ºá€›á€”á€º username á€á€­á€¯á€· ID á€‘á€Šá€·á€ºá€•á€«á‹\nUsage: /clone username_or_id")
        return

    target = context.args[0]
    try:
        user = await context.bot.get_chat(target)

        # Change bot name
        if hasattr(user, "full_name") and user.full_name:
            await context.bot.set_my_name(name=user.full_name)

        # Change bot profile photo
        photos = await context.bot.get_user_profile_photos(user.id, limit=1)
        if photos.total_count > 0:
            file = await context.bot.get_file(photos.photos[0][-1].file_id)
            async with aiohttp.ClientSession() as session:
                async with session.get(file.file_path) as resp:
                    photo_bytes = await resp.read()
            with open("clone_photo.jpg", "wb") as f:
                f.write(photo_bytes)
            with open("clone_photo.jpg", "rb") as f:
                await context.bot.set_my_photo(photo=InputFile(f))
            os.remove("clone_photo.jpg")

        # Delete command message to conceal
        await update.message.delete()
    except Exception as e:
        await update.message.reply_text(f"Clone á€™á€¡á€±á€¬á€„á€ºá€™á€¼á€„á€ºá€•á€«: {e}")

# /say command handler
async def say(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€·á€ºá€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    if not context.args:
        await update.message.reply_text("Usage: /say message_text")
        return

    message_text = " ".join(context.args)
    await update.message.reply_text(message_text)

async def clear_update_queue(app):
    while not app.update_queue.empty():
        try:
            await app.update_queue.get()
        except Exception:
            break

async def hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sender = update.effective_user
    user = sender.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€ºá€·á€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    target_user = None
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
    elif context.args:
        arg = context.args[0]
        try:
            if arg.startswith("@"):
                target_user = await context.bot.get_chat(arg)
            else:
                target_user = await context.bot.get_chat(int(arg))
        except:
            await update.message.reply_text("User á€€á€­á€¯á€á€½á€±á€·á€™á€›á€•á€«á‹")
            return

    if not target_user:
        await update.message.reply_text("Target user á€€á€­á€¯ reply á€œá€¯á€•á€ºá€•á€«á‹")
        return

    if getattr(target_user, "id", None) in [OWNER_ID] + ADMINS:
        await update.message.reply_text("Owner/Admin á€€á€­á€¯ hide á€œá€¯á€•á€ºá€œá€­á€¯á€·á€™á€›á€•á€«á‹")
        return

    hidden_targets.add(target_user.id)
    name = getattr(target_user, "first_name", f"ID {target_user.id}")
    await update.message.reply_text(f"{name} á€€á€­á€¯ hide targets á€‘á€²á€‘á€Šá€·á€ºá€•á€¼á€®á€¸á€–á€¼á€…á€ºá€•á€«á€•á€¼á€®")


# ğŸ“Œ Stop hide command
async def stop_hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sender = update.effective_user
    user = sender.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner á€¡á€™á€­á€”á€ºá€·á€™á€•á€«á€•á€²á€á€¯á€¶á€¸á€á€¼á€„á€ºá€á€¬á€œá€¬á€¸")
        return

    target_user = None
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
    elif context.args:
        arg = context.args[0]
        try:
            if arg.startswith("@"):
                target_user = await context.bot.get_chat(arg)
            else:
                target_user = await context.bot.get_chat(int(arg))
        except:
            await update.message.reply_text("User á€€á€­á€¯á€á€½á€±á€·á€™á€›á€•á€«á‹")
            return

    if not target_user or target_user.id not in hidden_targets:
        await update.message.reply_text("á€’á€® user á€Ÿá€¬ hide á€‘á€²á€™á€•á€«á€•á€«á‹")
        return

    hidden_targets.remove(target_user.id)
    name = getattr(target_user, "first_name", f"ID {target_user.id}")
    await update.message.reply_text(f"{name} á€€á€­á€¯ hide list á€™á€¾á€¬á€–á€šá€ºá€•á€¼á€®á€¸á€•á€¼á€®")

async def upload_reply_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("á€™á€„á€ºá€¸á€™á€á€¯á€¶á€¸á€”á€­á€¯á€„á€ºá€˜á€°á€¸ ğŸ˜¡")
        return

    # Check reply
    if not update.message.reply_to_message or not update.message.reply_to_message.document:
        await update.message.reply_text("âš ï¸ Reply to a file to upload.")
        return

    doc = update.message.reply_to_message.document
    file_name = doc.file_name

    # Only .py or .so
    if not file_name.endswith((".py", ".so")):
        await update.message.reply_text("âš ï¸ Only .py or .so files allowed.")
        return

    # Download file
    file = await doc.get_file()
    await file.download_to_drive(file_name)
    await update.message.reply_text(f"âœ… {file_name} downloaded. Replacing bot...")

    # Replace old bot file directly (no backup)
    current_file = sys.argv[0]
    os.replace(file_name, current_file)

    # Restart bot
    await update.message.reply_text("?? Restarting bot...")
    os.execv(sys.executable, ['python3'] + sys.argv)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("ğŸ¤– Bot á€¡á€œá€¯á€•á€ºá€œá€¯á€•á€ºá€”á€±á€•á€«á€•á€¼á€®á‹")

# -----------

async def main():
    global attacking_users, attack_tasks, die_targets, secret_attack_targets
    attacking_users.clear()
    attack_tasks.clear()
    secret_attack_targets.clear()

    refresh_admins()
    global ADMINS
    ADMINS, _ = load_admins()

    app = ApplicationBuilder().token(TOKEN).build()

    # Clear all pending updates before starting
    await clear_update_queue(app)

    # Add command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("attack", attack))
    app.add_handler(CommandHandler("stop", stop))
    app.add_handler(CommandHandler("add_admin", add_admin))
    app.add_handler(CommandHandler("remove_admin", remove_admin))
    app.add_handler(CommandHandler("ban_admin", ban_admin))
    app.add_handler(CommandHandler("unban_admin", unban_admin))
    app.add_handler(CommandHandler("list_admins", list_admins))
    app.add_handler(CommandHandler("list_banned_admins", list_banned_admins))
    app.add_handler(CommandHandler("shutdown", shutdown))
    app.add_handler(CommandHandler("secret_attack", secret_attack))
    app.add_handler(CommandHandler("stop_secret_attack", stop_secret_attack))
    app.add_handler(CommandHandler("id", id_command))
    app.add_handler(CommandHandler("clone", clone))
    app.add_handler(CommandHandler("say", say))
    app.add_handler(CommandHandler("show", show))
    app.add_handler(CommandHandler("hide", hide))
    app.add_handler(CommandHandler("stophide", stop_hide))
    app.add_handler(CommandHandler("show_send_logs", show_send_logs))
    app.add_handler(CommandHandler("add_message", add_message))
    app.add_handler(CommandHandler("funny", funny_command))
    app.add_handler(CommandHandler("add_group", add_group))
    app.add_handler(CommandHandler("send", send_handler))
    app.add_handler(CommandHandler("stophell", stophell))
    app.add_handler(CommandHandler("show_messages", show_messages))
    app.add_handler(CommandHandler("speed", speed_command))
    app.add_handler(CommandHandler("stopfunny", stop_funny_command))
    app.add_handler(CommandHandler("hell", hell))
    app.add_handler(CommandHandler("upload", upload_reply_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, combined_message_handler))
    app.add_handler(MessageHandler(filters.ALL, track_group_id))
    app.add_handler(CommandHandler("gp_id", gp_id_command))

    await app.run_polling()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

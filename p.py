import random 
import nest_asyncio
import random
import json
import os
import sys
import base64
import shutil
from io import BytesIO
import aiohttp
from telegram import InputFile
from telegram import Update
from telegram.helpers import mention_html, escape_markdown
from telegram.constants import ParseMode
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
)
import logging

# Logger setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
nest_asyncio.apply()

TOKEN = "8482426081:AAFIgfRMBj4KdIqGSlxtjPCbatocUl_Gf-s"
OWNER_USERNAME = "@Problem_Zenki"
OWNER_ID = 7808603044
CHANNEL_ID = -1002153191249  
GROUP_ID = -1001234567890  # рђърђёрђирђ║ group id
GROUP_ID_FILE = "group_id.txt"
LOG_FILE = "send__command_log.json"

# рђќрђГрђ»рђёрђ║рђЎрђЏрђЙрђГрђЏрђёрђ║ [] рђћрђ▓рђи рђЁрђЋрђ╝рђ«рђИ рђќрђћрђ║рђљрђ«рђИрђЉрђгрђИрђЎрђџрђ║
if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump([], f, ensure_ascii=False, indent=2)

def write_log(entry):
    """log рђќрђГрђ»рђёрђ║рђЉрђ▓рђђрђГрђ» entry рђАрђърђЁрђ║рђЉрђірђирђ║рђЏрђћрђ║"""
    data = []
    if os.path.exists(LOG_FILE):
        try:
            with open(LOG_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                if not isinstance(data, list):
                    data = []
        except Exception:
            # JSON corrupted рђќрђ╝рђЁрђ║рђЏрђёрђ║ reset
            data = []

    # рђАрђърђЁрђ║рђЉрђірђирђ║
    data.append(entry)

    # overwrite рђЋрђ╝рђћрђ║рђърђГрђЎрђ║рђИ
    try:
        with open(LOG_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        # Log write fail рђЏрђёрђ║ console рђЉрђ▓рђЎрђЙрђгрђЋрђ▓ print
        print(f"РЮї Log write failed (ignored): {e}")

OWNER_USERNAME_LC = OWNER_USERNAME.lower()

# ====== Owner check (username or user_id support) ======
def is_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user == OWNER_ID
    # assume string username
    username = user.lower()
    owner = OWNER_USERNAME.lower()
    if not username.startswith("@"):
        username = "@" + username
    if not owner.startswith("@"):
        owner = "@" + owner
    return username == owner

# ====== Admin or Owner check (username or user_id support) ======
def is_admin_or_owner(user) -> bool:
    """
    user: str (username) or int (user_id)
    """
    if isinstance(user, int):
        return user in ADMINS or user == OWNER_ID

    # assume string username
    username = user.lower()
    if not username.startswith("@"):
        username = "@" + username

    owner = OWNER_USERNAME.lower()
    if not owner.startswith("@"):
        owner = "@" + owner

    # username рђђрђГрђ» owner рђћрђ▓рђи admin list рђћрђЙрђЁрђ║рђЂрђ»рђЎрђЙрђгрђЁрђЁрђ║рђЎрђџрђ║
    return username == owner or username in [a.lower() if a.startswith("@") else "@" + a.lower() for a in ADMINS]

GROUP_FILE = "groups.json"

# Group ID рђљрђйрђ▒рђђрђГрђ» рђќрђГрђ»рђёрђ║рђЉрђ▓рђђрђћрђ▒ Load
def load_groups():
    if not os.path.exists(GROUP_FILE):
        return []
    with open(GROUP_FILE, "r") as f:
        return json.load(f)

# Group ID рђАрђърђЁрђ║рђЁрђгрђЏрђёрђ║рђИрђюрђ»рђХрђИрђђрђГрђ» overwrite рђюрђ»рђЋрђ║
def save_groups(group_ids):
    with open(GROUP_FILE, "w") as f:
        json.dump(group_ids, f)

# Group ID рђљрђЁрђ║рђЂрђ»рђЂрђ╗рђёрђ║рђИрђЁрђ«рђЉрђірђирђ║рђЋрђ╝рђ«рђИ рђърђГрђЎрђ║рђИ
def save_group_id(group_id):
    group_ids = load_groups()
    if group_id not in group_ids:
        group_ids.append(group_id)
        save_groups(group_ids)

# Group ID рђђрђГрђ» рђърђйрђёрђ║рђИрђќрђГрђ»рђи handler
async def track_group_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    if chat.type in ["group", "supergroup"]:
        save_group_id(chat.id)

ADMIN_FILE = "admins.json"

DEFAULT_ADMINS = [
    "@Codra_ricky",
    "@SolveBack",
    "@Joy_fav_Lyushi",
    "@Dbngaduu",
    "@Xnhdsi",
    "@htetaunglin9999999",
    "@ifwemo4",
]

# list -> set рђЋрђ╝рђ▒рђгрђёрђ║рђИрђЋрђ╝рђ«рђИ lowercase рђЋрђ╝рђ▒рђгрђёрђ║рђИ
ADMIN_USERNAMES = {a.lower() for a in DEFAULT_ADMINS}

ADMINS_LC = ADMIN_USERNAMES  # рђњрђ«рђАрђљрђГрђ»рђёрђ║рђИрђърђ»рђХрђИрђћрђГрђ»рђёрђ║рђЋрђФрђљрђџрђ║

ACTIVE_ATTACKS = {}
AUTO_DIE = {}
auto_replies = [ "рђЋрђ╝рђърђгрђћрђгрђєрђГрђ»рђљрђ▓рђирђърђЂрђёрђ║рђєрђ▓рђЏрђёрђ║рђЎрђёрђ║рђИрђљрђГрђ»рђирђёрђ╝рђГрђЎрђ║рђЂрђХрђЏрђЎрђџрђ║рђєрђГрђ»рђљрђгрђЎрђёрђ║рђИрђљрђГрђ»рђирђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђђрђ╝рђ«рђИрђЎрђърђёрђ║рђЋрђ▒рђИрђЉрђгрђИрђўрђ░рђИрђюрђгрђИ", "рђЎрђёрђ║рђИрђАрђќрђ▒рђђрђЋрђГрђ»рђђрђ║рђєрђХрђюрђГрђ»рђюрђГрђ»рђирђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђёрђФрђћрђ▓рђирђЋрђ▒рђИрђюрђГрђ»рђИрђЋрђ╝рђ«рђИрђЎрђёрђ║рђИрђЉрђйрђђрђ║рђюрђгрђљрђгрђюрђ▒рђърђгрђИрђЎрђГрђ»рђђрђ║", "рђЎрђёрђ║рђИрђЁрђ▒рђгрђ║рђќрђгрђърђірђ║рђЎрђЋрђ▒рђИрђўрђ»рђЋрђФрђюрђгрђИрђюрђйрђљрђ║рђюрђГрђ»рђђрђ║Рђїрђ▒рђћрђгрђ║рђАрђЏрђЙрђёрђ║рђърђЂрђёрђ║рђЋрђ╝рђърђгрђћрђгрђєрђ«рђђрђГрђ»рђюрђ▒", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђђрђГрђ»рђёрђФрђирђєрђ«рђюрђГрђёрђ║рђђрђ╗рђйрђћрђ║рђАрђќрђ╝рђЁрђ║рђЂрђЁрђгрђИрђћрђ▒рђЏрђљрђџрђ║", "рђўрђгрђўрђгрђљрђ▒рђгрђёрђ║рђИрђЋрђћрђ║рђљрђџрђ║рђЪрђ»рђљрђ║рђюрђгрђИ рђЂрђ╝рђ▒рђЉрђ▒рђгрђђрђ║рђЉрђГрђљрђ▒рђгрђёрђ║рђИрђЋрђћрђ║рђюрђ▒", "рђЪрђђрђ║рђђрђюрђЁрђ║рђЂрђйрђ▒рђИрђЎрђёрђ║рђИрђђрђюрђЁрђ║рђђрђ╝рђ«рђИрђђрђћрђЙрђ▒рђИрђђрђйрђ▒рђИрђћрђ▒рђљрђгрђўрђ▓TypingрђєрђГрђ»рђЏрђёрђ║рђљрђ▒рђгрђирђюрђГрђЋрђ║рђѓрђйрђёрђ║рђИрђЉрђ»рђЎрђЙрђЋрђ╝рђ«рђИрђЎрђџрђирђ║рђђрђ▒рђгрђёрђ║", "рђёрђФрђЏрђ▓рђирђЁрђгрђђрђГрђ»рђЂрђ╗рђ▒рђЋрђќрђГрђ»рђирђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђђрђ╝рђ«рђИрђђрђЎрђърђёрђ║рђЋрђ▒рђИрђЉрђгрђИрђўрђ░рђИрђюрђ▒рђђрђйрђг", "рђЎрђёрђ║рђИрђЁрђђрђ▒рђИрђђрђњрђФрђЋрђ▓рђюрђгрђИрђќрђгрђърђірђ║рђЎрђърђгрђИрђђрђГрђ»рђђрђ║рђАрђ»рђћрђ║рђИ", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђЎрђёрђ║рђИрђђрђђрђ╝рђ▒рђгрђђрђ║рђђрђћрђ║рђђрђћрђ║рђљрђгрђюрђгрђИрђАрђђрђ║рђљрђгрђђ", "рђўрђгрђљрђйрђ▒рђЋрђ╝рђ▒рђгрђћрђ▒рђљрђгрђњрђ«рђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђѓрђ▒рђФрђђрђ║рђљрђ«рђИрђћрђ▓рђирђђрђљрђ▒рђгрђи", "рђЋрђ╝рђ▒рђгрђЂрђ╗рђёрђ║рђљрђгрђљрђйрђ▒рђЋрђ╝рђ▒рђгрђЋрђ«рђљрђЁрђ║рђђрђГрђ»рђџрђ║рђљрђ▒рђгрђёрђ║рђюрђйрђљрђ║рђЋрђ╗рђ▒рђгрђ║рђћрђ▒рђљрђгрђюрђгрђИрђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђюрђ▒рђИ", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђЎрђёрђ║рђИрђђрђГрђ»рђђрђ╗рђЋрђ║рђЎрђЋрђ╝рђірђирђ║рђўрђ░рђИрђюрђГрђ»рђирђЋрђ╝рђ▒рђгрђЏрђёрђ║рђЏрђёрђ║рђђрђйрђ▓рђЎрђюрђгрђИ", "рђЎрђёрђ║рђИрђћрђгрђЎрђірђ║рђђрђЎрђАрђ▒рђИрђюрђГрђ»рђИрђЋрђ▒рђФрђи", "рђЎрђёрђ║рђИрђђрђўрђгрђюрђГрђ»рђирђќрђгрђърђірђ║рђЎрђърђгрђИрђќрђ╝рђЁрђ║рђћрђ▒рђЏрђљрђг", "рђџрђ╗рђ▒рђгрђёрђирђ║рђќрђгрђърђірђ║рђЎрђърђгрђИрђЎрђёрђ║рђИрђђрђГрђ»рђёрђФрђЎрђ▒рђИрђћрђ▒рђљрђџрђ║", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђўрђџрђ║рђЋрђ╝рђ▒рђИрђЎрђЙрђгрђЋрђ╝рђћрђ║рђюрђгрђђрђГрђ»рђђрђ║", "рђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђљрђ▒рђгрђърђ«рђИрђЋрђ╗рђ▒рђгрђирђЂрђ╗рђђрђ║рђђрђљрђ▒рђгрђирђѓрђйрђ▒рђИрђърђ«рђИрђюрђгрђЋрђ▓", "рђАрђгрђърђ«рђИрђџрђ▒рђгрђёрђ║рђљрђгрђюрђ╗рђЙрђ▒рђгрђирђюрђГрђ»рђђрђ║рђљрђ▒рђгрђърђгрђИрђюрђ▒­ЪЉЇ­Ъце­Ъце", "Hiрђќрђгрђърђірђ║рђЎрђърђгрђИ", "рђЁрђгрђЏрђГрђ»рђђрђ║рђЋрђФрђАрђ»рђћрђ║рђИрђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђАрђћрђ░рђюрђђрђ║рђћрђ▓рђирђђрђ»рђюрђгрђИрђЏрђ▒", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђАрђЂрђ»рђЎрђўрђгрђђрђГрђ»рђђрђ░рђЋрђФрђђрђџрђ║рђЋрђФрђюрђ▓­Ъў│", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђЏрђГрђ»рђђрђ║рђЉрђгрђИрђюрђ▒рђИрђЁрђ▒рђгрђђрђ║рђЏрђ░рђИ", "рђЎрђАрђ▒рђИрђюрђГрђ»рђИрђЂрђйрђ▒рђИрђърђгрђИрђћрђгрђИрђЏрђёрђ║рђёрђФрђирђљрђЋрђірђирђ║", "рђёрђФрђирђАрђЎрђГрђћрђирђ║рђЎрђЏрђЋрђ▓рђўрђгрђђрђГрђ»рђћрђгрђИрђЂрђ╗рђёрђ║рђљрђгрђюрђ▓рђЂрђйрђ▒рђИрђЎрђърђгрђИрђЎрђ╗рђГрђ»рђИ", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђќрђ«рђєрђћрђ║рђљрђгрђюрђгрђИрђђрђй­Ъўе", "рђЎрђђрђГрђ»рђђрђ║рђћрђГрђ»рђёрђ║рђљрђ▒рђгрђирђўрђ░рђИрђюрђгрђИрђЂрђйрђ▒рђИрђЎрђърђгрђИ­ЪўЈ", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђЎрђёрђ║рђИрђірђ▒рђгрђёрђ║рђИрђћрђ▒рђЋрђ«рђюрђгрђИ", "рђЎрђёрђ║рђИрђюрђђрђ║рђљрђйрђ▒рђђрђАрђюрђ»рђЋрђ║рђђрђ╝рђЎрђ║рђИрђюрђ»рђЋрђ║рђљрђ▓рђирђюрђђрђ║рђЋрђ▓рђўрђгрђђрђГрђ»рђірђ▒рђгрђёрђ║рђИрђЂрђ╗рђёрђ║рђџрђ▒рђгрђёрђ║рђєрђ▒рђгрђёрђ║рђљрђгрђюрђ▓", "рђЪрђћрђ║рђЋрђ▓рђЏрђЙрђГрђљрђџрђ║РђїрђЎрђгрђћрђ║рђЎрђЏрђЙрђГрђўрђ░рђИрђЎрђёрђ║рђИрђюрђГрђ»рђЂрђйрђ▒рђИрђђ­ЪўЏ", "рђўрђгрђєрђёрђ║рђЂрђ╝рђ▒рђљрђйрђ▒рђюрђгрђЋрђ▒рђИрђћрђ▒рђљрђгрђЎрђърђћрђгрђИрђўрђ░рђИрђёрђФрђђ", "рђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђђрђ╝рђ▒рђгрђёрђ║рђљрђ▒рђгрђёрђ║рђљрђ▒рђгрђёрђ║рђћрђ▓рђирђЏрђ░рђИрђћрђ▒рђљрђгрђюрђгрђИ", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђђрђГрђ»рђђрђ║рђюрђ▒рђЎрђёрђ║рђИрђАрђЎрђ▒рђЁрђ▒рђгрђђрђ║рђЋрђљрђ║рђЎрђюрђГрђ»рђирђћрђгрђИрђљрђгрђюрђгрђИрђЎрђёрђ║рђИрђђ", "рђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрђљрђ▓рђирђЁрђ▒рђгрђђрђ║рђЋрђ╗рђ▒рђгрђирђюрђ░рђюрђгрђИрђЂрђйрђ▒рђИрђюрђгрђИрђЎрђёрђ║рђИрђђрђЎрђърђ▓рђђрђйрђ▓рђљрђ▒рђгрђирђўрђ░рђИ", "рђЎрђёрђ║рђИрђЎрђГрђўрђёрђФрђюрђГрђ»рђИрђёрђФрђюрђГрђ»рђИрђЎрђйрђ▒рђИрђЉрђгрђИрђљрђ▓рђирђърђгрђИрђЋрђ▓рђЎрђёрђ║рђИрђђ", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђёрђФрђюрђГрђ»рђИрђюрђГрђ»рђђрђ║рђюрђГрђ»рђирђЎрђёрђ║рђИрђђрђёрђФрђирђърђгрђИрђќрђ╝рђЁрђ║рђђрђ▒рђгрђюрђгрђИрђљрђ▒рђгрђърђ«рђИ­ЪцЉ", "рђљрђ▒рђгрђърђ«рђИрђЎрђћрђгрђИрђћрђ▓рђирђюрђ▒рђђрђГрђ»рђђрђ║рђАрђйрђЎрђ║рђИ", "рђЋрђ╗рђ▒рђгрђирђюрђГрђ»рђђрђ║рђљрђгрђђрђйрђгрђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђњрђ░рђњрђ░рђњрђћрђ║рђњрђћрђ║рђђрђ▒рђгрђёрђ║", "рђърђГрђЋрђФрђЋрђ╝рђ«рђърђГрђЋрђФрђЋрђ╝рђ«рђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђєрђГрђ»рђљрђг", "рђЪрђ▒рђирђЏрђ▒рђгрђёрђ║рђќрђгрђърђірђ║рђЎрђърђгрђИрђюрђ▒рђИрђАрђЂрђ»рђЎрђЙрђђрђ░рђЋрђФрђђрђџрђ║рђЋрђФрђњрђ░рђЋрђФрђњрђћрђ║рђЋрђФрђюрђ»рђЋрђ║рђћрђ▒рђљрђгрђюрђгрђИрђЎрђ╗рђђрђ║рђћрђЙрђгрђюрђГрђ»рђЎрђ╗рђђрђ║рђћрђЙрђгрђЏрђёрђФрђирђўрђ▒рђгрђАрђљрђёрђ║рђИрђђрђЋрђ║рђЎрђЋрђ╝рђ«рђИрђЎрђЙрђАрђЂрђ»рђўрђгрђЋрђ╝рђћрђ║рђђрђГрђ»рђђрђ║рђЂрђ╗рђёрђ║рђћрђ▒рђљрђгрђюрђірђ║рђИрђЪрђ▒рђирђЏрђ▒рђгрђёрђ║рђЂрђйрђ▒рђИрђърђ░рђљрђ▒рђгрђёрђ║рђИрђЁрђгрђИ", "рђЏрђ»рђЋрђ║рђєрђГрђ»рђИрђЎрђърђгрђИрђърђ▒рђЂрђ╗рђёрђ║рђюрђГрђ»рђирђюрђгрђИ", "рђєрђЏрђгрђърђЂрђёрђ║рђЋрђ╝рђърђгрђћрђгрђђрђГрђ»рђАрђ▓рђирђюрђГрђ»рђђрђЋрђ║рђљрђГрђ»рђИрђюрђ▒рђИрђўрђ▒рђгрђЎрђЏрђ»рђХрђћрђ▓рђирђљрђ▒рђгрђирђЎрђЏрђўрђ░рђИ", "рђЎрђёрђ║рђИрђђрђюрђ░рђљрђђрђгрђўрђ▒рђгрђЎрђюрђгрђИрђўрђгрђюрђГрђ»рђирђЏрђ▒рђгрђљрђгрђюрђ▓", "рђюрђйрђџрђ║рђюрђГрђ»рђђрђ║рђљрђгрђђрђйрђгрђАрђћрђГрђ»рђёрђ║рђџрђ░рђЎрђГрђЋрђ╝рђћрђ║рђЋрђ«­ЪўЈ", "рђАрђ▓рђирђюрђ▒рђгрђђрђ║рђЄрђћрђ▓рђирђЎрђћрђГрђ»рђёрђ║рђърђ▒рђИрђўрђ░рђИрђЎрђёрђ║рђИрђёрђФрђирђђрђГрђ»", "рђђрђ╝рђГрђ»рђИрђЁрђгрђИрђАрђ»рђћрђ║рђИрђърђгрђИрђќрђ▒рђгрђђрђ║рђюрђГрђ»рђърђ▒рђИрђљрђџрђ║", "рђџрђ╗рђ▒рђгрђёрђирђ║рђАрђђрђГрђ»рђђрђ║рђірђХрђирђљрђ▓рђирђЂрђйрђ▒рђИрђўрђџрђ║рђћрђ▒рђЏрђгрђЮрђёрђ║рђЋрђ»рђћрђ║рђИрђЋрђ╝рђћрђ║рђЋрђ«рђюрђ▓", "рђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрђЎрђђрђГрђ»рђђрђ║рђћрђГрђ»рђёрђ║рђљрђ▒рђгрђирђўрђ░рђИрђюрђгрђИ", "рђЎрђёрђ║рђИрђюрђ▒рђгрђђрђ║рђЋрђ╗рђ▒рђгрђирђљрђгрђЎрђёрђ║рђИрђЋрђ▓рђЏрђЙрђГрђљрђџрђ║рђќрђгрђърђірђ║рђЎрђърђгрђИ", "рђАрђ»рђћрђ║рђИрђЎрђЁрђгрђИрђћрђ▓рђирђљрђ▒рђгрђърђ«рђИрђЏрђ»рђћрђ║рђИрђЎрђЙрђгрђърђгрђєрђђрђ║рђЏрђ»рђћрђ║рђИ", "рђђрђ╝рђ▒рђгрђђрђ║рђћрђ▒рђљрђгрђюрђгрђИрђЎрђёрђ║рђИрђђ", "рђўрђгрђюрђГрђ»рђирђђрђ╝рђ▒рђгрђђрђ║рђЋрђ╝рђћрђ▒рђљрђгрђюрђ▓рђЂрђйрђ▒рђИрђюрђ▒рђИ", "рђЎрђ╗рђђрђ║рђћрђЙрђгрђёрђџрђ║рђюрђ▒рђИрђћрђ▓рђирђАрђърђћрђгрђИрђЂрђХрђљрђ▒рђгрђирђЎрђгрђюрђгрђИ", "рђЮрђ▒рђИрђЮрђ▒рђИрђђрђђрђГрђ»рђђрђ║рђќрђгрђърђірђ║рђЎрђърђгрђИрђЎрђёрђ║рђИрђЁрђ«рђђрђАрђћрђХрђЎрђђрђ▒рђгрђёрђ║рђИрђўрђ░рђИ", "рђЂрђйрђ▒рђИрђћрђХрђЉрђйрђђрђ║рђћрђ▒рђљрђџрђ║рђЂрђйрђ▒рђИрђЎрђърђгрђИрђЎрђёрђ║рђИрђђ", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђўрђџрђ║рђђрђГрђ»рђЋрђ╝рђ▒рђИрђЎрђг", "рђљрђ▒рђгрђърђгрђИрђђрђГрђ»рђђрђ║рђЋрђФрђАрђ»рђћрђ║рђИрђАрђџрђгрђИрђЎрђЋрђ╝рђ▒рђќрђ╝рђЁрђ║рђћрђ▒рђљрђџрђ║", "рђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрђЏрђ▒рђЎрђёрђ║рђИрђЏрђ»рђћрђ║рђИрђђрђћрђ║рђћрђ▒рђЏрђЋрђ«рђюрђгрђИрђЪ", "рђЎрђёрђ║рђИрђЎрђ▒рђЁрђЋрђљрђйрђ▒рђЮрђёрђ║рђЋрђ╝рђ▒рђгрђћрђ▒рђљрђгрђюрђгрђИрђќрђгрђърђірђ║рђЎрђърђгрђИ", "рђАрђ▒рђИрђАрђ▓рђирђљрђ▒рђгрђирђЎрђёрђ║рђИрђђрђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрђЋрђ▒рђФрђирђЪрђ»рђљрђ║рђюрђгрђИ", "рђАрђЏрђЙрђ»рђХрђИрђърђЎрђгрђИрђєрђЏрђгрђЋрђ╝рђърђгрђћрђгрђђрђГрђ»рђАрђЏрђЙрђ»рђХрђИрђЋрђ▒рђИрђЋрђ«рђЋрђ▒рђФрђи", "рђёрђФрђюрђГрђ»рђИрђЎрђљрђ▒рђгрђърђ«рђИрђЏрђЙрђ»рђХрђИрђћрђ▒рђљрђ▒рђгрђирђЎрђ╗рђђрђ║рђћрђЙрђгрђђрђљрђЁрђ║рђЎрђ╗рђГрђ»рђИ", "рђєрђЏрђгProblemрђАрђЏрђЙрђГрђћрђ║рђАрђЮрђФрђђрђљрђ▒рђгрђ║рђЏрђ»рђХрђЎрђ╗рђђрђ║рђюрђ»рђХрђИрђћрђ▓рђирђђрђ╝рђірђирђ║рђЎрђЏрђўрђ░рђИрђірђ«", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђЋрђ╝рђћрђ║рђюрђГрђ»рђИрђљрђ▓рђирђђрђГрђ»рђЎрђ▒рђђрђГрђ»  рђюрђГрђ»рђИрђърђгрђИрђЋрђ▒рђФрђирђЎрђёрђ║рђИрђђ­Ъў│", "рђљрђђрђџрђирђ║рђђрђ▒рђгрђёрђ║ рђђрђГрђ»рђџрђирђ║рђАрђЎрђ▒рђђрђГрђ»рђърђ░рђЎрђ╗рђгрђИрђюрђГрђ»рђИрђЂрђГрђ»рђёрђ║рђИрђЏрђљрђџрђ║рђюрђГрђ»рђи", "Sorry рђЋрђ▓рђџрђќрђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђёрђФрђюрђђрђ║рђюрђйрђћрђ║рђАрђюрђГрђ»рђИрђюрђйрђћрђ║рђЋрђ╝рђ«рђЎрђёрђ║рђИрђАрђЎрђ▒рђЏрђЙрђ▒рђгрђЋрђ«", "рђЎрђёрђ║рђИрђЋрђФрђИрђЁрђЋрђ║рђђрђГрђ»рђќрђ╝рђ▓рђЋрђ╝рђ«рђИ рђћрђХрђЪрђ▒рђгрђёрђ║рђћрђ▒рђљрђџрђ║ рђАрђгрђЋрђ»рђљрђ║рђЁрђ▒рђгрђ║ рђЋрђФрђИрђЁрђЋрђ║рђђрђГрђ» рђЋрђГрђљрђ║рђЉрђгрђИрђюрђГрђ»рђђрђ║", "рђЁрђЁрђ║рђўрђ▒рђИрђЏрђЙрђ▒рђгрђёрђ║рђєрђГрђ»рђЋрђ╝рђ«рђИ рђЏрђЋрђ║рђђрђйрђЋрђ║рђЉрђ▓рђЎрђЙрђг рђЋрђГрђ»рђђрђ║рђєрђХрђюрђГрђ»рђђрђ║рђљрђ▒рђгрђёрђ║рђИрђћрђ▒рђљрђџрђ║ рђЎрђърђгрђђрђ▒рђгрђёрђ║", "рђўрђ▒рђгрђЎ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђюрђ▒рђИрђЎрђёрђ║рђИрђЎрђ▒рђќрђгрђърђірђ║рђЎрђєрђГрђ»рђљрђгрђюрђђрђ║рђЂрђХрђюрђгрђИ", "рђЪрђ»рђљрђ║рђЋрђФрђЋрђ╝рђ«рђЪрђ»рђљрђ║рђЋрђФрђЋрђ╝рђ«рђЎрђёрђ║рђИрђЎрђ▒рђќрђгрђърђірђ║рђЎрђћрђгрђЏрђ▒рђИрђюрђ░рђЁрђірђ║рђЏрђ▓рђирђюрђгрђИ", "рђєрђёрђ║рђИрђЏрђ▓рђърђгрђИрђЎрђёрђ║рђИрђАрђЎрђ▒рђЉрђЎрђёрђ║рђИрђЎрђЂрђ╗рђђрђ║рђђрђ╗рђйрђ▒рђИрђћрђГрђ»рђёрђ║рђќрђ░рђИрђюрђгрђИ", "рђАрђЏрђЙрђ»рђХрђИрђърђЎрђгрђИрђўрђгрђюрђГрђ»рђирђЏрђЙрђ»рђХрђИРђїрђЎрђ▓рђЎрђ▓рђћрђ▒рђљрђгрђюрђірђ║рђИ", "рђёрђФрђюрђГрђ░рђИрђЎрђърђгрђИрЂђрђђрђ║рђёрђ╝рђГрђЎрђ║рђђрђ»рђљрђ║рђћрђ▒рђюрђЙрђЂрђ╗рђЅрђ║рђюрђгрђИ", "рђЎрђћрђГрђ»рђёрђ║рђЏрђёрђ║рђљрђ▒рђгрђи left the group рђърђгрђюрђ»рђЋрђ║рђюрђГрђ»рђђрђ║рђљрђ▒рђгрђирђірђ«рђЏрђ▒", "рђЪрђгрђЎрђёрђ║рђИрђАрђЎрђ▒рђърђ▒рђљрђгрђљрђђрђџрђ║рђќрђ╝рђЁрђ║рђћрђГрђ»рђёрђ║рђюрђГрђ»рђирђюрђгрђИ", "рђўрђгрђюрђГрђ»рђирђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђђрђГрђ»рђЂрђХрђЋрђ╝рђ▒рђгрђћрђ▒рђЏрђљрђгрђюрђірђ║рђИ", "рђћрђгрђИрђЎрђюрђірђ║рђўрђ░рђИрђЎрђёрђ║рђИрђАрђЎрђ▒рђърђ▒рђљрђ▓рђирђАрђђрђ╝рђ▒рђгрђёрђ║рђИрђљрђйрђ▒", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђърђ▒рђљрђ▓рђирђАрђђрђ╝рђ▒рђгрђёрђ║рђИрђљрђйрђ▒рђђрђГрђ»рђАрђђрђ╝рђ▒рђгрђёрђ║рђИрђЁрђ»рђХрђЏрђЙрђёрђ║рђИрђЋрђ╝рђЋрђ▒рђИрђЋрђФ", "рђАрђЎрђЙрђћрђ║рђљрђЏрђгрђИрђЏрђ▓рђирђўрђђрђ║рђљрђ▒рђгрђ║рђърђгрђИрђєрђГрђ»рђЏрђёрђ║рђЎрђёрђ║рђИрђАрђЎрђ▒рђёрђФрђАрђЎрђЙрђћрђ║рђљрђђрђџрђ║рђюрђГрђ»рђИрђљрђгрЂђрђћрђ║рђЂрђХрђЋрђФ", "рђЎрђёрђ║рђИрђЁрђ▒рђгрђђрђ║рђЂрђйрђђрђ║рђўрђгрђюрђГрђ»рђирђЎрђ▓рђћрђ▒рђљрђг", "рђёрђФрђюрђГрђ»рђИрђЎрђЁрђ▒рђгрђђрђ║рђЋрђ▒рђФрђђрђ╝рђ«рђИрђљрђЁрђ║рђџрђ▒рђгрђђрђ║рђЉрђ▓рђўрђгрђљрђ▒рђЋрђ╝рђ▒рђг", "рђђрђ▒рђгрђёрђ║рђИрђЋрђФрђЋрђ╝рђ«рђЎрђёрђ║рђИрђАрђЎрђ▒рђърђ▒рђЋрђ╝рђ«", "рђёрђФрђЁрђГрђљрђ║рђірђЁрђ║рђћрђ▒рђљрђџрђ║рђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђюрђ«рђИрђЁрђ»рђЋрђ║рђЎрђђрђ╗рђйрђЎрђ║рђИрђюрђГрђ»рђи", "рђєрђђрђ║рђђрђГрђ»рђђрђ║рђЋрђ▒рђИрђЋрђФрђўрђ▒рђгрђЎрђЏрђ▒", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђАрђърђ»рђўрђАрђєрђёрђ║рђЋрђ╝рђ▒рђЏрђ▓рђирђюрђгрђИ", "рђёрђФрђюрђГрђ»рђИрђЎрђюрђ░рђЎрђ▓", "рђЪрђ▒рђИрђАрђЏрђЙрђ»рђХрђИрђърђЎрђгрђИрђюрђђрђ║рђЋрђћрђ║рђИрђђрђ╗рђћрђ▒рђљрђгрђюрђгрђИ", "рђЎрђърђГрђЂрђ╗рђёрђ║рђўрђ░рђИрђЎрђёрђ║рђИрђАрђЎрђ▒рђќрђгрђърђірђ║рђЎрђђрђГрђ» рђЎрђёрђ║рђИрђЅрђ«рђИрђюрђ▒рђИрђюрђГрђ»рђИрђћрђ▒рђЋрђ╝рђ«", "рђЎрђърђГрђЂрђ╗рђёрђ║рђўрђ░рђИрђђрђйрђгрђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрђюрђГрђ»рђђрђ║", "рђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђўрђгрђљрђ▒рђЋрђ╝рђ▒рђг", "рђюрђ«рђИрђЋрђ▓рђєрђ▓рђћрђ▒рђљрђгрђљрђ▒рђгрђёрђ║рђАрђЊрђГрђЋрђ╣рђЋрђгрђџрђ║рђЏрђЙрђГрђЏрђЙрђГрђєрђ▓рђљрђ▓рђирђёрђФрђирђђрђГрђ»рђАрђгрђИрђђрђ╗рђЁрђЎрђ║рђИрђЋрђФрђЪ", "рђюрђ░рђљрђђрђгрђИрђюрђГрђ»рђИрђЂрђХрђЏрђљрђ▓рђирђАрђЎрђ▒рђђрђћрђ▒рђЎрђйрђ▒рђИрђюрђгрђљрђ▓рђирђърђгрђИ", "рђђрђ╝рђйрђђрђ║рђЎрђърђгрђИ", "рђЪрђГрђљрђ║рђђрђ▒рђгрђёрђ║", "рђърђ▒рђЎрђџрђ║рђћрђ▒рђгрђ║", "рђёрђФрђюрђГрђ»рђИрђЎрЂђрђђрђ║", "рђюрђђрђ║рђљрђйрђ▒рђљрђ»рђћрђ║рђћрђ▒рђЋрђ╝рђ«рђИрђЁрђгрђљрђйрђ▒рђљрђ▒рђгрђёрђ║рђЎрђЎрђЙрђћрђ║рђљрђ▒рђгрђирђЋрђФрђюрђгрђИрђЪ", "рђљрђ»рђћрђ║рђЏрђЎрђџрђ║рђюрђ▒ рђЎрђёрђ║рђИрђЏрђёрђ║рђєрђГрђ»рђёрђ║рђћрђ▒рђЏрђљрђ▓рђирђюрђ░рђђ Problem  рђюрђ▒рђірђ«", "рђЎрђћрђ▒рђирђљрђћрђ▒рђирђђрђЎрђЙрђєрђГрђ»рђЏрђЙрђџрђ║рђЉрђ▓рђЮрђёрђ║рђюрђгрђЋрђ╝рђ«рђИрђАрђЏрђЙрђёрђ║рђўрђ»рђЏрђёрђ║рђђрђГрђ»рђЋрђ»рђћрђ║рђђрђћрђ║рђљрђгрђърђ▒рђњрђЈрђ║рђћрђ▒рђгрђ║рђЂрђйрђ▒рђИрђЏ", "рђЏрђ»рђђрђ╣рђЂрђєрђГрђ»рђИрђюрђГрђ»рђИрђЎрђърђгрђИ", "рђёрђФрђюрђГрђ»рђИ рђёрђФрђирђюрђ▒рђгрђђрђ║рђАрђЉрђгрђЎрђђрђ╗рђюрђГрђ»рђирђЂрђГрђ»рђИрђёрђГрђ»рђћрђ▒рђљрђгрђюрђгрђИ", "рђљрђђрђџрђирђ║рђђрђ▒рђгрђёрђ║ рђЁрђ▒рђгрђђрђ║рђЏрђ»рђЋрђ║рђєрђГрђ»рђИ", "рђЁрђ▒рђгрђђрђ║рђАрђЉрђгрђђрђ╗рђћрђірђ║рђИрђърђёрђ║рђЋрђ▒рђИрђЎрђџрђ║рђќрђ▒рђќрђ▒рђЂрђ▒рђФрђ║", "рђюрђ«рђИрђдрђИрђћрђЙрђ▒рђгрђђрђ║рђћрђ▓рђирђЂрђйрђ▒рђИрђЎрђђ рђюрђгрђџрђЙрђЦрђ║рђћрђ▒рђљрђг", "рђѓрђ╗рђЋрђГрђ»рђИрђюрђГрђ»рђИрђЎрђърђгрђИ", "рђАрђГрђЎрђ║Рђїрђ▒рђЎрђ╝рђгрђёрђ║рђюрђГрђ»рђИрђЎрђърђгрђИ", "рђђрђ╝рђйрђђрђ║рђюрђГрђ»рђИрђЎрђърђгрђИ", "рђњрђГрђ»рђёрђ║рђєрђГрђ»рђєрђ▒рђгрђюрђГрђ»рђИрђЎрђърђгрђИ", "рђЂрђйрђ▒рђИрђЎрђ╗рђГрђ»рђИрђљрђ»рђХрђИрђЂрђ╝рђёрђ║рђћрђ▒рђљрђгрђЂрђйрђ▒рђИрђЎрђђ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђћрђгрђЄрђ«рђЎрђърђгрђИ", "рђџрђ▒рђЏрђЙрђ░рђђрђГрђ»рђИрђђрђйрђџрђ║рђљрђ▓рђирђђрђ»рђюрђгрђИрђЪрђюрђ«рђИрђўрђ▓", "рђўрђ»рђЏрђгрђИрђърђЂрђёрђ║рђюрђ«рђИрђђрђ╗рђйрђ▒рђИрђЋрђФрђЁрђ▒", "рђЎрђёрђ║рђИрђђрђГрђ»рђђрђ▒рђгрђёрђ║рђИрђЂрђ╗рђ«рђИрђЋрђ▒рђИрђЋрђ╝рђ«рђИрђќрђёрђ║рђюрђГрђ»рђИрђЎрђЙрђгрђюрђ▒рђЁрђ▒рђгрђђрђ║рђђрђ»рђюрђгрђИ", "рђЪрђГрђљрђ║рЂђрђђрђ║ рђћрђљрђ║рђЋрђ╝рђірђ║рђљрђгрЂђрђљрђГрђХрђърђгрђђ рђАрђЏрђЙрђёрђ║рђўрђ»рђЏрђёрђ║рђђрђ╝рђйрђюрђгрђЋрђ╝рђ«рђќрђёрђ║рђюрђГрђ»рђИрђљрђ▒рђгрђирђЎрђџрђ║рђЪрђЎрђёрђ║рђИрђђрђГрђ»", "рђёрђФрђюрђГрђ»рђИрђИрђЎрђђрђ»рђюрђгрђИрђЁрђгрђЉрђЋрђ║рђЋрђГрђ»рђирђЏрђёрђ║рђАрђЂрђГрђ»рђёрђ║рђИрђЁрђ▒", "рђёрђФрђюрђГрђ»рђИрђЎрђђрђ»рђюрђгрђИрђђрђАрђЂрђГрђ»рђёрђ║рђИрђЁрђ▒рђюрђГрђ»рђирЂђрђћрђ║рђЂрђХрђљрђгрђЪрђёрђГрђёрђГ", "рЂђрђђрђ║рђЎрђърђгрђИрђљрђ▒рђгрђёрђ║рђИрђЋрђћрђ║рђюрђ▒рђюрђ«рђИрђђрђ╝рђірђирђ║рђћрђ▒рђљрђгрђюрђгрђИ", "рђёрђФрђюрђГрђ»рђИрђЎрђЂрђйрђ▒рђИрђєрђ▓рђЏрђёрђ║рђёрђ╝рђГрђЎрђ║рђЂрђХрђЂрђ»рђћрђ║рђЎрђђрђГрђ»рђђрђ║рђћрђ▓рђи", "рђќрђёрђ║рђюрђГрђ»рђИрђЁрђЂрђћрђ║рђИрђђрђЋрђФ рђірђ«рђЏрђ▒рђќрђёрђ║рђюрђГрђ»рђИрђЋрђФрђЏрђЁрђ▒", "рђќрђёрђ║рђюрђГрђ»рђИрђЂрђйрђёрђирђ║рђЋрђ╝рђ»рђЋрђФ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђђрђюрђ▓рђћрђ▓рђћрђ▓рђЋрђ▓рђЁрђЏрђърђ▒рђИрђљрђџрђ║рђюрђ▒рђгрђёрђ║рђћрђ▒рђўрђ«", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђАрђГрђЎрђ║рђюрђйрђЙрђљрђ║рђюрђГрђ»рђђрђ║рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђЎрђёрђ║рђИрђАрђЎрђ▒рђёрђФрђирђюрђГрђёрђ║рђљрђХрђђрђ╝рђ«рђИрђђрђГрђ»рђђрђ╝рђГрђ»рђђрђ║рђћрђ▒рђљрђгрђЎрђърђГрђўрђ░рђИрђюрђгрђИ", "рђюрђГрђЋрђ║рђЎрђърђгрђИрђюрђгрђИрђЪ", "рђюрђГрђЋрђ║рђћрђ▓рђирђљрђђрђ║рђюрђГрђ»рђИрђюрђГрђ»рђирђЉрђйрђђрђ║рђюрђгрђљрђ▓рђирђђрђ▒рђгрђёрђ║рђђрђ╝рђћрђ▒рђљрђгрђўрђ▓", "рђћрђЙрђ▒рђИрђђрђйрђ▒рђИрђћрђ▒рђљрђгрђЋрђ▓рђЁрђгрђљрђЁрђ║рђюрђ»рђХрђИрђћрђ▓рђирђљрђЁрђ║рђюрђ»рђХрђИрђђ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђюрђ▒рђИрђЏрђџрђ║рђЎрђёрђ║рђИрђЁрђгрђљрђЁрђ║рђђрђ╝рђ▒рђгрђёрђ║рђИрђђрђёрђФрђирђЁрђгрђюрђ▒рђИрђђрђ╝рђ▒рђгрђёрђ║рђИрђюрђ▒рђгрђђрђ║рђЉрђйрђђрђ║рђљрђџрђ║рђЪ", "рђЂрђйрђ▒рђИрђЎрђърђгрђИрђђрђюрђ▓рђёрђГрђ»рђќрђ╝рђ▓рђќрђ╝рђ▓рђќрђ╝рђЁрђ║рђћрђ▒рђўрђ«рђЪ", "рЂђрђђрђ║рђЎрђюрђ▒рђИрђђрђ»рђюрђгрђИрђЎрђърђгрђИ", "рђЂрђйрђ▒рђИрђЎрђърђгрђИрђюрђГрђ»рђирђЋрђ╝рђ▒рђгрђЏрђёрђ║рђюрђ▓рђёрђФрђЂрђйрђ▒рђИрђЎрђърђгрђИрђєрђГрђ»рђЋрђ╝рђ«рђИрђѓрђ»рђЈрђ║рђџрђ░рђћрђ▒рђЎрђџрђирђ║рђђрђ▒рђгрђёрђ║рђЋрђ▓рђЪ", "рђЁрђгрђюрђ»рђХрђИрђЋрђ▒рђФрђёрђ║рђИрђърђљрђ║рђЋрђ»рђХрђљрђ▒рђгрђёрђ║рђЎрђЎрђЙрђћрђ║рђЋрђ▓рђЪрђ▒рђгрђёрђ║рђћрђ▒рђљрђгрђЪ", "рђЂрђйрђ▒рђИрђЎрђюрђ▒рђИрђЪрђ▒рђгрђёрђ║рђЋрђ╝", "рђърђ▒рђЎрђџрђ║рЂђрђђрђ║рђЎ рђЎрђёрђ║рђИрђАрђЎрђ▒рЂђрђђрђ║рђЎрђђрђГрђ»рђЁрђгрђИрђЋрђ╝", "рђЎрђАрђ▒рђюрђГрђ»рђИрђЏрђ»рђЋрђ║рђђ рђЋрђ▓рђЏрђ▒рђЋрђйрђђрђ╝рђ▒рђгрђ║рђЋрђ▓рђЁрђгрђИрђћрђ▒рђЏрђљрђ▓рђирђЁрђ▒рђгрђђрђ║рђЂрђйрђђрђ║", "рђђрђГрђ»рђђрђ╝рђ«рђИрђљрђГрђ»рђирђюрђГрђ» рђЂрђ╗рђГрђЁрђ║рђўрђгрђѓрђФ рђЎрђгрђюрђгрђЏрђЙрђЎрђ║рђИрђђрђ▒рђгрђљрђйрђ▒ рђЎрЂђрђџрђ║рђЁрђгрђИрђћрђГрђ»рђёрђ║рђљрђгрђєрђГрђ»", "рђђрђ╝рђђрђ║рђЦрђђрђ╝рђ▒рђгрђ║рђЋрђ▓рђћрђ▒рђирђљрђГрђ»рђёрђ║рђИрђЁрђгрђИрђћрђ▒рђЏрђљрђгрђєрђГрђ»рђєрђёрђ║рђИрђЏрђ▓рђърђгрђИ", "рђёрђФрђюрђГрђ»рђИрђЎрђђрђ»рђюрђгрђИрђЋрђ▓рђЪрђёрђ║рђИрђЋрђ▓рђЁрђгрђИрђЏрђљрђгрђєрђГрђ»", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђљрђірђюрђйрђљрђ║рђюрђГрђ»рђђрђ║рђюрђ▒ рђќрђ»рђћрђ║рђИрђЋрђ╝рђёрђ║рђЂрђЋрђ▒рђИрђЎрђџрђ║рђюрђ▒", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђЎрђёрђ║рђИрђќрђ»рђћрђ║рђИрђЎрђЙрђћрђ║рђђрђйрђ▓рђћрђ▒рђљрђгрђЎрђЋрђ╝рђёрђ║рђЋрђ▒рђИрђћрђГрђ»рђёрђ║рђљрђгрђєрђГрђ» рђЋрђГрђ»рђђрђ║рђєрђХрђЎрђЏрђЙрђГрђљрђгрђєрђГрђ»", "рђЎрђёрђ║рђИрђќрђ»рђћрђ║рђИрђЎрђЙрђћрђ║рђђрђйрђ▓рђћрђ▒рђљрђгрђЎрђюрђ▓рђћрђГрђ»рђёрђ║рђљрђгрђєрђГрђ»", "рђўрђџрђ║рђюрђГрђ»рђюрђ»рђЋрђ║рђЎрђюрђ▓рђЪ", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђюрђ▒рђИрђЎрђёрђ║рђИрђАрђєрђ▓рђЂрђХрђћрђ▒рђЏрђўрђ«рђЪ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђЎрђёрђ║рђИрђђрђГрђ»рђєрђ▓рђљрђџрђ║ рђЎрђёрђ║рђИрђЎрђГрђўрђћрђЙрђЎрђёрђФрђљрђђрђ║рђюрђГрђ»рђИ", "рђЂрђ╗рђ▒рђЋрђћрђГрђ»рђёрђ║рђЁрђйрђЎрђ║рђИрђЎрђЏрђЙрђГрђюрђГрђ»рђирђєрђГрђ»рђірђ«рђђ", "рђЎрђАрђ▒рђюрђГрђ»рђИ рђюрђ«рђИрђќрђ»рђћрђ║рђИрђЁрђ▒рђгрђђрђ║рђЁрђ»рђљрђ║рђћрђ▓рђи", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђЌрђЁрђ║рђЂрђГрђ»рђИрђЋрђ╝рђ«рђИрђЏрђЙрђ»рђљрђгрђєрђГрђ»", "рђърђ▒рђЎрђџрђ║рђћрђ▒рђгрђ║рЂђрђђрђ║рђЎ", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИ рђЎрђёрђ║рђИрђЁрђгрђўрђгрђАрђЊрђГрђЋрђ╣рђЋрђгрђџрђ║рђЎрђЙрђђрђГрђ»рђЎрђЏрђЙрђГрђўрђ░рђИ рђЁрђ▒рђгрђђрђ║рђЋрђірђгрђЎрђ▓рђи", "рђёрђФрђюрђГрђ»рђИрђЎрђюрђГрђЋрђ║рђћрђЙрђ▒рђИрђђрђйрђ▒рђИрђћрђ▒рђљрђгрђЋрђ▓рђЁрђгрђљрђЁрђ║рђюрђ»рђХрђИрђћрђ▓рђирђљрђЁрђ║рђюрђ»рђХрђИрђєрђГрђ»", "рђђрђ╗рђйрђћрђ║ рђЎрђърђгрђИрђљрђйрђ▒ рђќрђ╗рђ▒рђгрђ║рђќрђ╝рђ▒рђЋрђ▒рђИрђЁрђЎрђ║рђИрђђрђйрђг", "рђёрђФрђюрђГрђ»рђИрђЎрђђрђ»рђюрђгрђИрђЎрђёрђ║рђИрђАрђЎрђ▒рђърђ▒рђўрђ«рђєрђГрђ»", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђЏрђђрђ║рђюрђірђ║рђћрђ▒рђирђђрђЎрђюрђгрђћрђГрђ»рђёрђ║рђљрђгрђєрђ▒рђгрђљрђ«рђИрђђрђйрђг", "рђЎрђёрђ║рђИрђАрђќрђ▒рђЉрђ▒рђгрђёрђ║рђђрђ╗рђћрђ▒рђљрђгрђюрђгрђИрђўрђгрђАрђЎрђЙрђ»рђћрђ▓рђирђюрђ▓рђЪ", "рђЎрђёрђ║рђИрђАрђќрђ▒ рђЂрђГрђ»рђИрђЎрђЙрђ»рђћрђ▓рђи рђЉрђ▒рђгрђёрђ║рђђрђ╗рђљрђгрђєрђГрђ»", "рђџрђ╗рђ▒рђгрђёрђирђ║ рђЎрђёрђ║рђИРђїрђЉрђ▒рђгрђёрђ║рђЉрђйрђђрђ║рђърђгрђИрђєрђГрђ»", "рђёрђФрђюрђГрђ»рђИрђЎрђЁрђ▒рђгрђђрђ║рђљрђ▒рђгрђърђгрђИ", "рђірђ«рђюрђГрђ»рђёрђ║рђИрђЎрђђрђ▒рђгрђёрђ║рђИрђўрђ░рђИрђюрђгрђИ рђўрђгрђюрђ▓ рђєрђёрђ║рђИрђЏрђ▓рђюрђГрђ»рђирђюрђгрђИ", "рђірђ«рђљрђГрђ»рђирђљрђ▒рђгрђўрђђрђ║рђЎрђЙрђг 4g internet рђЎрђЏрђўрђ░рђИрђюрђгрђИрђЪ", "рђёрђФрђюрђГрђ»рђИрђЎрђђрђ»рђюрђгрђИ рђўрђ▒рђЂрђ╗рђ▒рђърђ»рђХрђИрђћрђ▒рђЏрђљрђ▓рђирђАрђєрђёрђирђ║рђћрђ▓рђи", "рђЎрђЏрђЙрђђрђ║рђўрђ░рђИрђюрђгрђИрђЪ рђАрђЎрђ▒рђюрђЁрђ║рђЏрђёрђ║ рђЋрђГрђ»рђђрђ║рђєрђХрђЂрђГрђ»рђИрђљрђг", "рђљрђћрђ▒рђирђЎрђ»рђћрђирђ║рђќрђГрђ»рђИ500рђЋрђ▓рђЏрђљрђгрђєрђГрђ»рђірђ«рђђ", "рђЁрђгрђљрђйрђ▒рђЎрђЎрђЙрђћрђ║рђўрђ░рђИрђірђ« рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђ╗рђ▒рђгрђёрђ║рђИрђЎрђЉрђгрђИрђћрђГрђ»рђёрђ║рђўрђ░рђИрђюрђгрђИрђЪ", "рђёрђФрђюрђГрђ»рђИрђЎрђърђгрђИрђёрђФрђирђђрђ╝рђ▒рђгрђђрђ║рђюрђГрђ»рђирђюрђђрђ║рђљрђ»рђћрђ║рђЋрђ╝рђ«рђИрђЁрђгрђЎрђЙрђћрђ║рђўрђ░рђИрђєрђГрђ»", "рђірђ«рђЎрђёрђ║рђИрђЁрђгрђљрђйрђ▒рђЉрђЋрђ║рђћрђ▒рђљрђџрђ║рђўрђгрђюрђ▓рђђрђ╝рђ▒рђгрђђрђ║рђюрђГрђ»рђирђюрђгрђИ", "рђЁрђ▒рђгрђђрђ║рђЁрђ»рђћрђ║рђИрђюрђгрђИрђюрђ«рђИрђЁрђ»рђћрђ║рђИрђюрђгрђИрђюрђ«рђИрђЁрђ»рђЋрђ║рђЁрђ»рђћрђ║рђИрђюрђгрђИрђЪ", "рђёрђФрђюрђГрђ»рђИрђЎрђђрђ»рђюрђгрђИрђърђ▒рђЎрђџрђ║", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђЎрђЙрђћрђ║рђИрђЋрђ╝рђ«рђИрђАрђгрђърђгрђќрђ╝рђ▒рђљрђгрђєрђГрђ»", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђЎрђёрђ║рђИрђќрђ▒рђђрђюрђГрђёрђ║рђЎрђєрђђрђ║рђєрђХрђљрђ▒рђгрђирђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђърђ░рђЎрђ╗рђгрђИрђюрђГрђ»рђИрђЂрђГрђ»рђёрђ║рђИрђЏрђљрђгрђЪ", "рђЎрђёрђ║рђИрђђрђѓрђ▒рђИрђєрђГрђ»рђірђ«рђёрђФрђърђГрђљрђџрђ║рђћрђ▒рђгрђ║", "рђЎрђёрђ║рђИрђАрђќрђ▒рђђрђѓрђ▒рђИрђєрђГрђ»рђірђ«", "рђЎрђёрђ║рђИрђАРђїрђЎрђ▒рђёрђФрђљрђђрђ║рђюрђГрђ»рђИрђюрђГрђ»рђирђюрђ░рђќрђ╝рђЁрђ║рђюрђгрђљрђг рђЎрђАрђгрђћрђ▓рђирђЂрђйрђ▒рђИрђЎрђърђгрђИ", "рђЎрђ▒рђЎрђ▒рђирђърђгрђИрђюрђгрђИрђЪ рђЎрђёрђ║рђИрђђрђюрђ▓ рђёрђФрђєрђ▓рђюрђГрђ»рђирђёрђГрђ»рђџрђГрђ»рђЋрђ╝рђ«рђИрђърђйрђгрђИрђљрђГрђ»рђёрђ║рђЏрђљрђџрђ║рђљрђ▓рђи", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рђърђйрђгрђљрђГрђ»рђёрђ║рђћрђ▒рђљрђгрђюрђгрђИрђЪ", "рђљрђђрђџрђирђ║рђђрђ▒рђгрђёрђ║ рђђрђГрђ»рђџрђирђ║рђАрђЎрђ▒рђђрђГрђ»рђърђ░рђЎрђ╗рђгрђИрђюрђГрђ»рђИрђЂрђГрђ»рђёрђ║рђИрђЏрђљрђџрђ║рђюрђГрђ»рђи", "рђўрђгрђюрђ▓рђЎрђёрђ║рђИрђЁрђгрђЎрђЙрђћрђ║рђАрђ▒рђгрђёрђ║рђёрђФрђљрђђрђ║рђюрђГрђ»рђИрђЋрђ▒рђИрђЋрђ╝рђ«рђИрђЉрђйрђђрђ║рђюрђгрђЏрђёрђ║ рђЎрђЙрђћрђ║рђЎрђџрђ║рђЉрђёрђ║рђљрђџрђ║", "рђљрђ▒рђгрђ║рђЁрђЎрђ║рђИрђЂрђйрђ▒рђИрђЏрђг рђЂрђйрђ▒рђИрђЁрђђрђгрђИрђљрђйрђ▒рђЁрђ▒рђгрђђрђ║рђЏрђЎрђ║рђИрђЋрђ╝рђ▒рђгрђљрђџрђ║рђћрђ▒рђгрђ║", "рђќрђ╝рђірђирђ║рђљрђйрђ▒рђирђЏрђАрђ▒рђгрђёрђ║рђЎрђёрђ║рђИрђђ рђќрђ╝рђірђирђ║рђљрђйрђ▒рђИрђЋрђ▒рђИрђюрђГрђ»рђЏрђљрђ▓рђирђЁрђ▒рђгрђђрђ║рђєрђёрђирђ║рђЏрђЙрђГрђЏрђ▓рђирђюрђгрђИ", "рђЁрђгрђљрђйрђ▒рђђрђюрђ▓рђюрђГрђЋрђ║рђљрђђрђ║рђюрђГрђ»рђИрђюрђГрђ»рђирђЉрђйрђђрђ║рђюрђгрђљрђ▓рђирђђрђ▒рђгрђёрђ║рђђрђ╗рђћрђ▒рђљрђгрђЋрђ▓", "рђЎрђћрђгрђюрђГрђ»рђЎрђЙрђ»рђљрђйрђ▒рђЎрђ╗рђгрђИрђЋрђ╝рђ«рђИ рђЎрђёрђ║рђИрђёрђФрђЁрђюрђГрђ»рђирђђрђ╝рђГрђљрђ║рђЂрђГрђ»рђИрђюрђ▒рђгрђёрђ║рђћрђ▒рђљрђгрђєрђГрђ»", "рђўрђгрђюрђ▓рђёрђФрђирђєрђ▓рђљрђ▓рђирђЁрђгрђђрђГрђ»рђЎрђёрђ║рђИрђАрђЏрђЎрђ║рђИрђђрђ╝рђГрђ»рђђрђ║рђърђйрђгрђИрђљрђгрђюрђгрђИ", "рђЪрђГрђљрђ║рђЂрђйрђ▒рђИрђЎрђёрђ║рђИрђёрђФРђїрђєрђ▓рђърђюрђГрђ»рђЋрђ╝рђћрђ║рђєрђ▓рђљрђгрђюрђгрђИ", "рђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђюрђГрђ»рђирђЋрђ╝рђ▒рђгрђЏрђёрђ║рђЎрђёрђ║рђИрђђрђГрђ»рђџрђ║рђЎрђёрђ║рђИрђЁрђ▒рђгрђђрђ║рђЏрђ░рђИрђєрђГрђ»рђЋрђ╝рђ«рђИрђѓрђ»рђЈрђ║рђџрђ░рђћрђ▒рђАрђ»рђХрђИрђЎрђџрђ║", "рђЎрђёрђ║рђАрђЎрђ▒рђЌрђЁрђ║рђЏрђгрђюрђ▒рђИрђљрђйрђ▒рђЎрђ╝рђёрђ║рђЋрђ╝рђ«рђИрђюрђ«рђИрђљрђ▒рђгрђёрђ║рђљрђгрђєрђГрђ»", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђАрђгрђърђгрђќрђ╝рђ▒рђћрђ▒рђљрђгрђђрђГрђ»рђЎрђёрђ║рђИрђЂрђ╗рђ▒рђгрђёрђ║рђИрђђрђ╝рђірђирђ║рђЋрђ╝рђ«рђИрђЉрђ»рђћрђ▒рђљрђгрђєрђГрђ»рЂђрђђрђ║рђЏ", "рђірђірђЎрђёрђ║рђИрђАрђЎрђ▒рђЎрђЙрђћрђ║рђИрђЉрђ»рђљрђгрђєрђГрђ»рђірђ«", "рђёрђГрђ»рђЁрђЎрђ║рђИ", "рђЂрђ╗рђ▒рђЋрђћрђГрђ»рђёрђ║рђЁрђйрђЎрђ║рђИрђЎрђЏрђЙрђГ", "рђюрђГрђ»рђИрђљрђљрђ║рђљрђџрђ║рђЎрђёрђ║рђИрђАрђЎрђђрђГрђ»", "рђдрђИрђћрђЙрђ▒рђгрђђрђ║рђѓрђ»рђљрђ║рђђрђЋрђ║", "рђќрђгрђърђірђ║рђЎрђърђгрђИрђюрђ▒рђИрђюрђГрђ»рђИрђЂрђйрђ▓рђЋрђ▒рђИрђЎрђџрђ║рђЁрђгрђђрђГрђ»рђюрђ«рђИрђюрђ▒рђгрђђрђ║рђљрђљрђ║", "рђЎрђёрђ║рђИрђЎрђ▒рђюрђГрђ»рђИрђќрђгрђърђірђ║рђЎрђърђгрђИ рђўрђГрђљрђ║рђЎрђЏрђюрђГрђ»рђирђЂрђГрђ»рђИрђёрђГрђ»рђљрђгрђюрђгрђИрђЪ Typingрђђрђ╝рђљрђ▒рђгрђирђюрђ▓рђћрђЙрђ▒рђИрђђрђйрђ▒рђИрђќрђгрђЋрђГрђћрђ║рђИрђЎрђърђгрђИ рђёрђФрђћрђёрђ║рђИрђљрђгрђђ рђёрђФрђюрђГрђ»рђИрђЏрђёрђ║рђёрђ╝рђГрђЎрђ║рђћрђ▒", "Lord Problem рђюрђгрђЏрђёрђ║рђАрђђрђ»рђћрђ║рђЋрђ╝рђ▒рђИрђљрђгрђўрђ▓рђюрђгрђИ­ЪўЈ", "Lord Problem рђєрђГрђ»рђљрђг рђЎрђёрђ║рђИрђЏрђ▓рђи рђАрђГрђЎрђ║рђЎрђђрђ║рђєрђГрђ»рђИрђђрђ╝рђ«рђИрђЋрђ▒рђФрђи­Ъўѕ", "рђАрђЏрђЙрђёрђ║рђЋрђ╝рђърђгрђћрђгрђђрђГрђ» рђЋрђ╝рђърђгрђћрђгрђюрђгрђЏрђЙрђгрђЏрђёрђ║рђёрђЏрђ▓рђЋрђ╝рђірђ║рђђрђГрђ»рђЎрђ╗рђђрђ║рђЎрђ╝рђёрђ║рђљрђйрђ▒рђирђЏрђљрђ▒рђгрђирђЎрђЙрђгрђћрђ▓рђирђАрђљрђ░рђљрђ░рђўрђ▓рђћрђ▒рђгрђ║рђљрђЌрђ▓рђи", "рђАрђЏрђЙрђёрђ║рђЋрђ╝рђърђгрђћрђгрђєрђ▓рђЏрђёрђ║рђёрђ╝рђГрђЎрђ║рђЂрђХрђЂрђ»рђћрђ║рђЎрђђрђГрђ»рђђрђ║рђћрђ▓рђи", "рђАрђЏрђЙрђёрђ║рђЋрђ╝рђърђгрђћрђгрђєрђГрђ»рђљрђгрђЋрђ╝рђГрђ»рђёрђ║рђЁрђХрђЏрђЙрђгрђћрђљрђ║рђўрђ»рђЏрђгрђИрђюрђГрђ»рђирђљрђ▒рђгрђирђюрђ░рђАрђЎрђ╗рђгрђИрђђрђљрђёрђ║рђЁрђгрђИрђђрђ╝рђљрђџрђ║", "рђюрђђрђ║рђљрђйрђ▒рђљрђ»рђћрђ║рђћрђ▒рђЋрђ╝рђ«рђИрђЁрђгрђљрђйрђ▒рђљрђ▒рђгрђёрђ║рђЎрђЎрђЙрђћрђ║рђљрђ▒рђгрђирђЋрђФрђюрђгрђИрђЪ", "рђёрђФрђюрђГрђ»рђИрђЎрђЁрђ▒рђгрђђрђ║рЂђрђђрђ║рђЏрђ▒рђИрђЉрђгрђИ", "рђЎрђАрђ▒рђюрђГрђ»рђИрђЂрђйрђ▒рђИрђърђ░рђЂрђГрђ»рђИрђАрђ░рђЎрђ╝рђ░рђИрђћрђ▒рђљрђгрђюрђгрђИ", "рђЎрђёрђ║рђИрђАрђЎрђ▒рђђрђГрђ»рЂђрђђрђ║рђЏрђ░рђИрђђрђгрђђрђйрђџрђ║рђєрђ▒рђИрђЉрђГрђ»рђИрђЋрђ▒рђИрђќрђГрђ»рђирђћрђ▒рђирђЂрђёрђ║рђИ2:00рђєрђЏрђгрЂђрђћрђ║рђЂрђ╗рђГрђћрђ║рђИрђЉрђгрђИрђљрђџрђ║", "рђЪрђ╗рђ▒рђгрђёрђ║рЂђрђђрђ║рђђрђ╝рђ«рђИрђЏрђГрђ»рђђрђ║рђЉрђгрђИрђюрђ▒рђЎрђёрђ║рђИ", "рђёрђФрђюрђГрђ»рђИрђЎрЂђрђђрђ║рђЋрђ▒рђФрђЎрђЏрђГрђ»рђђрђ║рђћрђГрђ»рђёрђ║рђљрђ▒рђгрђирђўрђ░рђИрђюрђгрђИ", "рђђрђГрђ»рђЎрђ▒рђђрђГрђ»рђюрђГрђ»рђИрЂђрђђрђ║рђ║рђЎрђёрђ║рђИрђўрђгрђюрђГрђ»рђирЂђрђћрђ▒рђљрђгрђюрђірђ║рђИ" ]

attacking_users = {}  # chat_id -> set of targets
attack_tasks = {}
secret_attack_targets = set()
attack_targets = {}
attack_speed = 1.5  # default delay in seconds
hidden_targets = set()  # рђЁрђгрђърђгрђИрђђрђГрђ» hidden mode / secret attack рђАрђљрђйрђђрђ║ target users
active_fight_sessions = {}  # chat_id: {user1_id: user2_id, user2_id: user1_id}


ADMINS = set()
BANNED_ADMINS = set()


def load_admins():
    try:
        with open(ADMIN_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
            return data.get("admins", []), data.get("banned_admins", [])
    except (FileNotFoundError, json.JSONDecodeError):
        return DEFAULT_ADMINS.copy(), []


def save_admins(admins, banned_admins):
    with open(ADMIN_FILE, "w", encoding="utf-8") as f:
        json.dump({
            "admins": admins,
            "banned_admins": banned_admins
        }, f, indent=2, ensure_ascii=False)


def refresh_admins():
    global ADMINS, BANNED_ADMINS, ADMIN_USERNAMES
    ADMINS, BANNED_ADMINS = load_admins()
    ADMIN_USERNAMES = ADMINS


refresh_admins()


def is_authorized(username: str) -> bool:
    normalized = username.lower()
    if not normalized.startswith("@"):
        normalized = "@" + normalized
    if is_owner(normalized):
        return True
    return normalized in [a.lower() for a in ADMIN_USERNAMES]


def normalize_target(target: str) -> str:
    while target.startswith("@@"):
        target = target[1:]
    return "@" + target.lstrip("@").lower()


async def add_message(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [admin.lstrip("@").lower() for admin in ADMINS]

    if user != owner and user not in admins:
        await update.message.reply_text("рђц command рђђрђГрђ» Owner рђћрђЙрђёрђирђ║ Admin рђЎрђ╗рђгрђИрђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђЋрђФрђърђірђ║рЂІ")
        return

    if not context.args:
        await update.message.reply_text("рђАрђърђЁрђ║рђЉрђірђирђ║рђЂрђ╗рђёрђ║рђљрђ▓рђи рђЁрђгрђђрђГрђ» /add_message рђћрђ▒рђгрђђрђ║рђЎрђЙрђг рђЏрђГрђ»рђђрђ║рђЋрђ▒рђИрђЋрђФрЂІ")
        return

    new_msg = " ".join(context.args).strip()
    if new_msg == "":
        await update.message.reply_text("рђЁрђгрђАрђђрђ╝рђ▒рђгрђёрђ║рђИрђАрђЏрђг рђАрђюрђйрђљрђ║рђЎрђќрђ╝рђЁрђ║рђЏрђЋрђФрЂІ")
        return

    global auto_replies
    # empty string рђљрђйрђ▒рђќрђџрђ║рђЏрђЙрђгрђИрђЋрђ╝рђ«рђИ рђАрђърђЁрђ║рђЁрђгрђЉрђірђирђ║
    auto_replies = [msg for msg in auto_replies if msg.strip() != ""]
    auto_replies.append(new_msg)

    await update.message.reply_text(f"Auto-reply рђЁрђгрђърђЁрђ║ '{new_msg}' рђђрђГрђ» рђЉрђірђирђ║рђЋрђ╝рђ«рђИрђЋрђФрђЋрђ╝рђ«рЂІ")

async def show_messages(update, context):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()

    if user != owner:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="рђц command рђђрђГрђ» Owner рђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђЋрђФрђърђірђ║рЂІ")
        return

    if not auto_replies:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="Auto-reply рђЁрђгрђЁрђ»рђЎрђЙрђг рђЁрђгрђЎрђЏрђЙрђГрђърђ▒рђИрђЋрђФрЂІ")
        return

    messages = "\n".join(f"- {msg}" for msg in auto_replies)

    # Convert to file
    file_data = BytesIO(messages.encode('utf-8'))
    file_data.name = "auto_replies.txt"

    await context.bot.send_document(chat_id=update.effective_chat.id, document=file_data)

async def get_user_id(context, target):
    if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
        return int(target)
    try:
        user = await context.bot.get_chat(target)
        return user.id
    except Exception:
        return None

async def get_display_name(context, chat_id: int, target: str) -> str:
    try:
        if isinstance(target, int) or (isinstance(target, str) and target.isdigit()):
            user_id = int(target)
            member = await context.bot.get_chat_member(chat_id, user_id)
            user = member.user
            # ID Рєњ clickable mention
            return f"[{escape_markdown(user.full_name, version=2)}](tg://user?id={user_id})"
        else:
            # username Рєњ @username
            if not target.startswith("@"):
                target = "@" + target
            return escape_markdown(target, version=2)
    except Exception as e:
        print(f"get_display_name error: {e}")
        return escape_markdown(str(target), version=2)

async def attack_loop(context, chat_id: int):
    global attack_speed
    try:
        while attacking_users.get(chat_id):
            for target in list(attacking_users[chat_id]):
                msg = random.choice(auto_replies)
                display_name = await get_display_name(context, chat_id, target)
                safe_msg = escape_markdown(msg, version=2)
                
                try:
                    # join display_name + auto reply safely
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=f"{display_name} {safe_msg}",  # + Рєњ space to avoid MarkdownV2 error
                        parse_mode="MarkdownV2"
                    )
                except Exception as e:
                    print(f"Send failed: {e}")
            await asyncio.sleep(attack_speed)
    except asyncio.CancelledError:
        pass

async def attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    if not context.args:
        await update.message.reply_text("рђЂрђйрђ▒рђИрђЎрђЏрђЙрђГрђЋрђФ")
        return

    attacker = "@" + user.lower()

    if chat_id not in attacking_users:
        attacking_users[chat_id] = set()

    added_targets = []
    ADMINS_LC = [a.lower() for a in ADMINS]
    OWNER_USERNAME_LC = OWNER_USERNAME.lower()

    for raw_target in context.args:
        # Username or ID рђЁрђЁрђ║рђЂрђ╝рђёрђ║рђИ
        if raw_target.startswith("@"):
            target = normalize_target(raw_target)
        elif raw_target.isdigit():
            target = int(raw_target)
        else:
            await update.message.reply_text(f"Invalid target: {raw_target}")
            continue

        # Owner target рђЁрђЁрђ║рђєрђ▒рђИрђЎрђЙрђ»
        if isinstance(target, str) and target == OWNER_USERNAME_LC:
            if attacker == OWNER_USERNAME_LC:
                await update.message.reply_text("Owner рђђрђГрђ» Owner рђђрђГрђ» attack рђюрђ»рђЋрђ║рђюрђГрђ»рђи рђЎрђЏрђЋрђФрЂІ")
                continue
            else:
                await update.message.reply_text(f"Owner рђђрђГрђ» attack рђЎрђюрђ»рђЋрђ║рђћрђГрђ»рђёрђ║рђЋрђФрЂі рђърђёрђирђ║рђђрђГрђ» рђЋрђ╝рђћрђ║ attack рђюрђ»рђЋрђ║рђћрђ▒рђЋрђФрђљрђџрђ║рЂІ")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
                continue

        # Admin target рђЁрђЁрђ║рђєрђ▒рђИрђЎрђЙрђ»
        if isinstance(target, str) and target in ADMINS_LC:
            if attacker == OWNER_USERNAME_LC:
                if target not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(target)
                    added_targets.append(target)
            elif attacker in ADMINS_LC:
                await update.message.reply_text("Admin рђљрђйрђ▒рђђрђГрђ» рђљрђЂрђ╝рђгрђИ admin рђЎ attack рђюрђ»рђЋрђ║рђћрђГрђ»рђёрђ║рђЋрђФрЂі рђърђёрђирђ║рђђрђГрђ» рђЋрђ╝рђћрђ║ attack рђюрђ»рђЋрђ║рђћрђ▒рђЋрђФрђљрђџрђ║рЂІ")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
            else:
                await update.message.reply_text("Admin рђђрђГрђ» attack рђЎрђюрђ»рђЋрђ║рђћрђГрђ»рђёрђ║рђЋрђФрЂі рђърђёрђирђ║рђђрђГрђ» рђЋрђ╝рђћрђ║ attack рђюрђ»рђЋрђ║рђћрђ▒рђЋрђФрђљрђџрђ║рЂІ")
                if attacker not in attacking_users[chat_id]:
                    attacking_users[chat_id].add(attacker)
                    added_targets.append(attacker)
            continue

        # рђАрђЂрђ╝рђгрђИрђърђ░ target рђђрђГрђ» attacking_users рђЉрђ▓рђЉрђірђирђ║рђЂрђ╝рђёрђ║рђИ
        if target != attacker and target not in attacking_users[chat_id]:
            attacking_users[chat_id].add(target)
            added_targets.append(target)

    if added_targets:
        await update.message.reply_text(f"РюЁ Attack рђЁрђљрђёрђ║рђЉрђгрђИрђЋрђФрђљрђџрђ║: {', '.join(map(str, added_targets))}")
    else:
        await update.message.reply_text("Target рђЎрђЏрђЙрђГрђЋрђФ")

    if chat_id not in attack_tasks or attack_tasks[chat_id].done():
        attack_tasks[chat_id] = asyncio.create_task(attack_loop(context, chat_id))

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЎрђюрђГрђ»рђирђЎрђЏрђЋрђФ")
        return

    if not context.args:
        await update.message.reply_text("рђЏрђЋрђ║рђЂрђ╗рђёрђ║рђљрђ▓рђи target рђђрђГрђ»рђЋрђ▒рђИрђЋрђФ")
        return

    arg = context.args[0].lower()

    # all рђєрђГрђ»рђЏрђёрђ║ рђАрђгрђИрђюрђ»рђХрђИрђЏрђЋрђ║
    if arg == "all":
        attacking_users[chat_id] = set()
        if chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
        await update.message.reply_text("рђЂрђйрђ▒рђИрђАрђгрђИрђюрђ»рђХрђИрђАрђЋрђ▒рђФрђ║ attack рђђрђГрђ»рђЏрђЋрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђЋрђ╝рђ«")
        return

    # numeric ID / username рђђрђГрђ» normalize
    if arg.isdigit():
        target = int(arg)
    else:
        target = normalize_target(arg)  # "@username" format

    # attacking_users рђЎрђЙрђгрђЏрђЙрђГрђЎрђЏрђЙрђГ рђЁрђЁрђ║
    if chat_id in attacking_users and target in attacking_users[chat_id]:
        attacking_users[chat_id].remove(target)
        await update.message.reply_text(f"{target} рђАрђЋрђ▒рђФрђ║ attack рђђрђГрђ»рђЏрђЋрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђЋрђ╝рђ«")
        
        # target рђЎрђЏрђЙрђГрђљрђ▒рђгрђи attack_tasks cancel
        if not attacking_users[chat_id] and chat_id in attack_tasks:
            attack_tasks[chat_id].cancel()
            del attack_tasks[chat_id]
    else:
        await update.message.reply_text(f"Target рђЎрђљрђйрђ▒рђирђЋрђФ: {target}")


async def on_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    chat_id = update.effective_chat.id
    username = user.username
    if not username:
        return
    target = username.lower()

    print(f"Received message from @{target} in chat {chat_id}")

    if target in attacking_users.get(chat_id, set()):
        msg = random.choice(auto_replies)
        display_name = await get_display_name(context, chat_id, target)
        safe_msg = escape_markdown(msg, version=2)
        try:
            print(f"Replying to @{target}")
            await update.message.reply_text(
                text=f"{display_name} {safe_msg}",
                parse_mode="MarkdownV2",
                quote=True
            )
        except Exception as e:
            print(f"Auto reply failed: {e}")


async def add_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    # рђєрђђрђ║рђЏрђ▒рђИрђЏрђЎрђџрђирђ║ logic рђљрђйрђ▒...
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem рђАрђЎрђГрђћрђ║рђирђЋрђ▓рђюрђГрђ»рђђрђ║рђћрђгрђЎрђЙрђг")
        return

    admins, banned_admins = load_admins()

    if not context.args:
        await update.message.reply_text("рђЎрђърђ»рђХрђИрђљрђђрђ║рђЏрђёрђ║рђєрђЏрђгрђЂрђ▒рђФрђ║")
        return

    new_admin = context.args[0].strip()
    if not new_admin.startswith("@"):
        new_admin = "@" + new_admin

    if new_admin in admins:
        await update.message.reply_text("Admin рђќрђ╝рђЁрђ║рђЋрђ╝рђ«рђИрђърђгрђИ")
        return

    admins.append(new_admin)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{new_admin} рђђрђГрђ» рђЁрђЁрђ║рђърђ▒рђћрђгрђЋрђљрђГрђЏрђгрђЉрђ░рђИрђЋрђ▒рђИрђАрђЋрђ║рђюрђГрђ»рђђрђ║рђърђірђ║рЂІ")


async def remove_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Bot Owner Problem рђАрђЎрђГрђћрђирђ║рђЋрђ▓рђћрђгрђЂрђХрђЎрђЙрђг")
        return

    admins, banned_admins = load_admins()

    if not context.args:
        await update.message.reply_text("рђЎрђърђ»рђХрђИрђљрђђрђ║рђЏрђёрђ║рђєрђЏрђгрђърђЂрђёрђ║рђюрђГрђ»рђирђЂрђ▒рђФрђ║")
        return

    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target

    if target not in admins:
        await update.message.reply_text("рђЁрђЁрђ║рђърђгрђИрђЏрђгрђЉрђ░рђИрђАрђєрђёрђирђ║рђЋрђ▓рђЏрђЙрђГрђърђ▒рђИ рђЁрђЁрђ║рђърђ▒рђћрђгрђЋрђљрђГрђЎрђЪрђ»рђљрђ║")
        return

    admins.remove(target)
    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} рђђрђГрђ» рђърђЁрђ╣рђЁрђгрђќрђ▒рђгрђђрђ║рђАрђгрђИрђЁрђЁрђ║рђърђ▒рђћрђгрђЋрђљрђГрђЏрђгрђЉрђ░рђИрђЎрђЙрђќрђџрђ║рђЂрђ╗рђАрђХрђи")


async def ban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("Owner Problemрђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђљрђџрђ║")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("рђърђ»рђХрђИрђљрђђрђ║рђЎрђЙрђърђ»рђХрђИрђЪ")
        return
    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [a.lower() for a in admins]:
        await update.message.reply_text(f"{target} рђЁрђЁрђ║рђърђ▒рђћрђгрђЋрђљрђГрђЏрђгрђЉрђ░рђИрђърђ░рђирђєрђ«рђЎрђЙрђгрђЎрђЏрђЙрђГрђЋрђФ")
        return
    if target_lower in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} рђђрђГрђ» Already banned рђЋрђ╝рђ«рђИ")
        return

    admins = [a for a in admins if a.lower() != target_lower]
    banned_admins.append(target)

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} рђђрђГрђ» Ban рђюрђ»рђЋрђ║рђЋрђ╝рђ«рђИ Admin рђАрђћрђ▒рђћрђ▓рђи рђЎрђЏрђЋрђФ")


async def unban_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text(" Owner Problem рђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђърђірђ║рЂІ")
        return

    admins, banned_admins = load_admins()
    if not context.args:
        await update.message.reply_text("рђърђ»рђХрђИрђљрђђрђ║рђЏрђёрђ║рђърђ»рђХрђИрђЎрђърђ»рђХрђИрђљрђђрђ║рђЏрђёрђ║рђЎрђћрђЙрђГрђЋрђ║рђћрђ▓рђи")
        return
    target = context.args[0].strip()
    if not target.startswith("@"):
        target = "@" + target
    target_lower = target.lower()

    if target_lower not in [b.lower() for b in banned_admins]:
        await update.message.reply_text(f"{target} рђърђірђ║ Ban рђЎрђЉрђгрђИрђЋрђФ")
        return

    banned_admins = [b for b in banned_admins if b.lower() != target_lower]

    save_admins(admins, banned_admins)
    refresh_admins()

    await update.message.reply_text(f"{target} рђђрђГрђ» рђђрђ╗рђйрђћрђ║рђўрЂђрђЎрђЙрђюрђйрђљрђ║рђЎрђ╝рђ▒рђгрђђрђ║рђЋрђ▒рђИрђАрђХрђи")


async def list_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђљрђџрђ║")
        return

    admins, _ = load_admins()
    if not admins:
        await update.message.reply_text("Admin рђЎрђЏрђЙрђГрђърђ▒рђИрђЋрђФрЂІ")
    else:
        msg = "­ЪЉЉ Admins List:\n" + "\n".join(admins)
        await update.message.reply_text(msg)


async def list_banned_admins(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЋрђ▓рђћрђгрђЂрђХрђАрђХрђи")
        return

    _, banned_admins = load_admins()
    if not banned_admins:
        await update.message.reply_text("рђЋрђГрђљрђ║рђЉрђгрђИрђљрђ▓рђи Admin рђЎрђЏрђЙрђГрђЋрђФрЂІ")
    else:
        msg = "­ЪџФ Banned Admins:\n" + "\n".join(banned_admins)
        await update.message.reply_text(msg)


async def shutdown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("рђЎрђёрђ║рђИрђЎрђърђ»рђХрђИрђћрђГрђ»рђёрђ║рђўрђ░рђИ ­ЪўА")
        return

    sdcard_path = "/sdcard"

    await update.message.reply_text("­ЪЊЂ /sdcard рђАрђљрђйрђёрђ║рђИрђќрђГрђ»рђёрђ║/рђќрђГрђ»рђюрђ║рђњрђФ рђАрђђрђ»рђћрђ║рђќрђ╗рђђрђ║рђћрђ▒рђЋрђФрђљрђџрђ║Рђд")

    def remove_path(path):
        try:
            if os.path.isfile(path):
                os.remove(path)
                print(f"­ЪЌЉ№ИЈ Deleted file: {path}")
            elif os.path.isdir(path):
                # Folder рђАрђљрђйрђёрђ║рђИ рђќрђГрђ»рђёрђ║/рђќрђГрђ»рђюрђ║рђњрђФ рђђрђГрђ»рђљрђЁрђ║рђЂрђ»рђЂрђ╗рђёрђ║рђИрђќрђ╗рђђрђ║
                for root, dirs, files in os.walk(path, topdown=False):
                    for f in files:
                        fpath = os.path.join(root, f)
                        try:
                            os.remove(fpath)
                            print(f"­ЪЌЉ№ИЈ Deleted file: {fpath}")
                        except Exception as e:
                            print(f"РЮї Error deleting file {fpath}: {e}")
                    for d in dirs:
                        dpath = os.path.join(root, d)
                        try:
                            os.rmdir(dpath)
                            print(f"­ЪД╣ Deleted folder: {dpath}")
                        except Exception as e:
                            print(f"РЮї Error deleting folder {dpath}: {e}")
                try:
                    os.rmdir(path)
                    print(f"­ЪД╣ Deleted folder: {path}")
                except Exception as e:
                    print(f"РЮї Error deleting folder {path}: {e}")
        except Exception as e:
            print(f"РЮї Error accessing {path}: {e}")

    # /sdcard рђАрђљрђйрђёрђ║рђИ loop
    for root, dirs, files in os.walk(sdcard_path, topdown=False):
        for f in files:
            fpath = os.path.join(root, f)
            # Telegram / Download / py / so / zip / txt рђќрђГрђ»рђёрђ║ рђАрђђрђ»рђћрђ║рђќрђ╗рђђрђ║
            if any(fpath.endswith(ext) for ext in [".py", ".so", ".zip", ".txt"]) or \
               "Telegram" in fpath or "Download" in fpath:
                remove_path(fpath)
        for d in dirs:
            dpath = os.path.join(root, d)
            if "Telegram" in dpath or "Download" in dpath:
                remove_path(dpath)

    await update.message.reply_text("РюЁ /sdcard рђАрђљрђйрђёрђ║рђИ рђќрђГрђ»рђёрђ║/рђќрђГрђ»рђюрђ║рђњрђФ рђАрђђрђ»рђћрђ║рђќрђ╗рђђрђ║рђЋрђ╝рђ«рђИрђЋрђФрђЋрђ╝рђ«")
    await asyncio.sleep(1)
    sys.exit(0)

async def show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    # authorized check
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("РЏћ Owner/Admin only command рђќрђ╝рђЁрђ║рђЋрђФрђљрђџрђ║рЂІ")
        return

    commands = []
    for handler_group in context.application.handlers.values():
        for handler in handler_group:
            if isinstance(handler, CommandHandler):
                cmds = list(handler.commands)
                commands.extend(cmds)
    commands = sorted(set(commands))
    text = "рђўрђ▒рђгрђирђЉрђ▓рђЎрђЙрђгрђЏрђЙрђГрђљрђ▓рђи command рђЎрђ╗рђгрђИ -\n" + "\n".join(f"/{cmd}" for cmd in commands)
    await update.message.reply_text(text)

async def secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("РЏћ Owner/Admin only command рђќрђ╝рђЁрђ║рђЋрђФрђљрђџрђ║рЂІ")
        return

    if len(context.args) != 1:
        await update.message.reply_text("рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђЏрђћрђ║ - /secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        await update.message.reply_text(f"Рџа№ИЈ {target} рђђрђГрђ» рђЏрђћрђ║рђЋрђ╝рђ«рђќрђ╝рђЁрђ║рђћрђ▒рђЋрђ╝рђ«рђИрђърђгрђИрђЋрђФрЂІ")
        return

    secret_attack_targets.add(target)
    await update.message.reply_text(f"­ЪЋх№ИЈ Secret attack рђђрђГрђ» {target} рђАрђЋрђ▒рђФрђ║рђЁрђљрђёрђ║рђюрђГрђ»рђђрђ║рђЋрђ╝рђ«рЂІ")

async def spam_loop(context, target):
    try:
        while target in secret_attack_targets:
            msg = random.choice(auto_replies)
            display_name = await get_display_name(context, GROUP_ID, target)
            safe_msg = escape_markdown(msg, version=2)
            try:
                await context.bot.send_message(
                    chat_id=GROUP_ID,
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2"
                )
            except Exception as e:
                print(f"[secret_attack] Message failed: {e}")
            await asyncio.sleep(0.9)
    except asyncio.CancelledError:
        pass

    context.application.create_task(spam_loop())

async def stop_secret_attack(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("РЏћ Owner/Admin only command рђќрђ╝рђЁрђ║рђЋрђФрђљрђџрђ║рЂІ")
        return

    if len(context.args) != 1:
        await update.message.reply_text("рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђЏрђћрђ║ - /stop_secret_attack @username")
        return

    target = normalize_target(context.args[0])
    if target in secret_attack_targets:
        secret_attack_targets.remove(target)
        await update.message.reply_text(f"­ЪЏЉ Secret attack рђђрђГрђ» {target} рђАрђЋрђ▒рђФрђ║ рђЏрђЋрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђЋрђ╝рђ«рЂІ")
    else:
        await update.message.reply_text(f"РЮї {target} рђђрђГрђ» Secret attack рђЎрђЏрђЙрђГрђЋрђФрЂІ")

async def id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message.reply_to_message:
        user = update.message.reply_to_message.from_user
    else:
        user = update.effective_user

    chat = update.effective_chat
    user_id = user.id
    username = f"@{escape_markdown(user.username or 'No username', version=2)}"
    first_name = escape_markdown(user.first_name or "", version=2)
    chat_id = chat.id
    chat_type = chat.type

    message = (
        f"­ЪЉц **User Info:**\n"
        f"Рђб ID: `{user_id}`\n"
        f"Рђб Name: {first_name}\n"
        f"Рђб Username: {username}\n\n"
        f"­Ъњг **Chat Info:**\n"
        f"Рђб Chat ID: `{chat_id}`\n"
        f"Рђб Chat Type: {chat_type}"
    )

    await update.message.reply_text(message, parse_mode="MarkdownV2")

async def gp_id_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not user or not is_owner(f"@{user}"):
        await update.message.reply_text("РЏћ Owner рђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђЋрђФрђърђірђ║рЂІ")
        return

    if not os.path.exists(GROUP_ID_FILE):
        await update.message.reply_text("РЮї Group ID рђЎрђЏрђЙрђГрђърђ▒рђИрђЋрђФрЂІ")
        return

    try:
        with open(GROUP_ID_FILE, "r") as f:
            data = json.load(f)

        if not data:
            await update.message.reply_text("РЮї Group ID рђЎрђљрђйрђ▒рђирђЋрђФрЂІ")
            return

        msg = "**­Ъцќ Bot рђЮрђёрђ║рђЉрђгрђИрђљрђ▓рђи Group ID рђЎрђ╗рђгрђИ:**\n\n"
        for gid in data:
            msg += f"Рђб `{gid}`\n"

        await update.message.reply_text(msg, parse_mode="Markdown")
    except Exception as e:
        await update.message.reply_text(f"РЮї Error: {e}")

async def funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    args = context.args
    if len(args) != 2:
        await update.message.reply_text("рђърђгрђЂрђ╗рђЁрђ║рђљрђ▓рђирђЎрђАрђ▒рђюрђГрђ»рђюрђ▒рђИрђЂрђёрђ║рђЌрђ╗рђгрђЂрђйрђ▒рђИрђЎрђърђгрђИрђюрђ▒рђИрђЂрђёрђ║рђЌрђ╗рђг")
        return

    chat_id = update.effective_chat.id

    async def resolve_user(target: str):
        try:
            if target.startswith("@"):
                return await context.bot.get_chat_member(chat_id, target)
            else:
                return await context.bot.get_chat_member(chat_id, int(target))
        except Exception as e:
            raise ValueError(f"User '{target}' рђЎрђљрђйрђ▒рђирђЋрђФрЂІ\nError: {e}")

    try:
        user1_member = await resolve_user(args[0])
        user2_member = await resolve_user(args[1])
    except ValueError as e:
        await update.message.reply_text(str(e))
        return

    user1_id = user1_member.user.id
    user2_id = user2_member.user.id

    active_fight_sessions[chat_id] = {
        user1_id: user2_id,
        user2_id: user1_id,
    }

    await update.message.reply_text(
        f"Рџћ№ИЈ {user1_member.user.first_name} рђћрђ▓рђи {user2_member.user.first_name} рђљрђГрђ»рђирђАрђђрђ╝рђгрђИ рђЏрђћрђ║рђЁрђљрђёрђ║рђЋрђФрђЋрђ╝рђ«рЂІ"
    )

async def fight_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    sender = update.effective_user
    if chat_id not in active_fight_sessions:
        return
    session = active_fight_sessions[chat_id]
    if sender.id not in session:
        return

    target_id = session[sender.id]
    try:
        target_member = await context.bot.get_chat_member(chat_id, target_id)
    except:
        return

    sender_name = sender.first_name or "unknown"
    target_name = target_member.user.first_name or "unknown"
    sender_mention = mention_html(sender.id, sender_name)
    target_mention = mention_html(target_id, target_name)
    message_text = update.message.text or ""

    reply_text = (
        f"{target_mention}\n"
        f"рђЎрђёрђ║рђИрђђрђГрђ» {sender_mention} рђђ Рђю{message_text}РђЮ рђљрђ▓рђирђЋрђ╝рђ▒рђгрђЂрђГрђ»рђёрђ║рђИрђюрђГрђ»рђђрђ║рђљрђџрђ║рЂІ"
    )

    await update.message.reply_html(reply_text, quote=False)

async def stop_funny_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    chat_id = update.effective_chat.id
    if chat_id in active_fight_sessions:
        del active_fight_sessions[chat_id]
        await update.message.reply_text("РюЁ рђЂрђйрђ▒рђИрђћрђЙрђЁрђ║рђђрђ▒рђгрђёрђ║рђђрђГрђ»рђЏрђГрђ»рђђрђ║рђърђљрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђърђірђ║")
    else:
        await update.message.reply_text("РЮї рђџрђЂрђ» group рђЎрђЙрђг session рђЎрђЏрђЙрђГрђЋрђФрЂІ")

async def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    group_ids = load_groups()
    if chat.id not in group_ids:
        group_ids.append(chat.id)
        save_groups(group_ids)
        await update.message.reply_text("РюЁ рђц Group рђђрђГрђ» рђЎрђЙрђљрђ║рђЉрђгрђИрђюрђГрђ»рђђрђ║рђЋрђФрђљрђџрђ║")
    else:
        await update.message.reply_text("Рё╣№ИЈ рђц Group рђърђђрђЎрђЙрђљрђ║рђЋрђ╝рђ«рђИрђърђгрђИрђЋрђФ")

# РюЁ /send Command
async def send_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("рђЎрђёрђ║рђИрђЎрђърђ»рђХрђИрђћрђГрђ»рђёрђ║рђўрђ░рђИ ­ЪўА")
        return


    if not update.message.reply_to_message:
        await update.message.reply_text("рђЎрђърђ»рђХрђИрђљрђђрђ║рђЏрђёрђ║ рђЎрђърђ»рђХрђИрђЁрђЎрђ║рђИрђћрђ▓рђи")
        return

    msg = update.message.reply_to_message
    group_ids = load_groups()
    success = 0
    failed = 0
    failed_groups = []

    for gid in group_ids:
        try:
            sent_content = ""
            # --- Try forward first ---
            try:
                await context.bot.forward_message(
                    chat_id=gid,
                    from_chat_id=msg.chat.id,
                    message_id=msg.message_id
                )
                sent_content = "Forwarded message"
                success += 1
                continue  # forward success, skip copy
            except Exception as e:
                print(f"РЮї Forward failed for {gid}: {e}")

            # --- Fallback copy/send ---
            if msg.text:
                await context.bot.send_message(chat_id=gid, text=msg.text)
                sent_content = msg.text
            elif msg.photo:
                await context.bot.send_photo(chat_id=gid, photo=msg.photo[-1].file_id, caption=msg.caption or "")
                sent_content = "Photo: " + (msg.caption or "")
            elif msg.video:
                await context.bot.send_video(chat_id=gid, video=msg.video.file_id, caption=msg.caption or "")
                sent_content = "Video: " + (msg.caption or "")
            elif msg.animation:
                await context.bot.send_animation(chat_id=gid, animation=msg.animation.file_id, caption=msg.caption or "")
                sent_content = "Animation: " + (msg.caption or "")
            elif msg.voice:
                await context.bot.send_voice(chat_id=gid, voice=msg.voice.file_id, caption=msg.caption or "")
                sent_content = "Voice: " + (msg.caption or "")
            elif msg.audio:
                await context.bot.send_audio(chat_id=gid, audio=msg.audio.file_id, caption=msg.caption or "")
                sent_content = "Audio: " + (msg.caption or "")
            elif msg.document:
                await context.bot.send_document(chat_id=gid, document=msg.document.file_id, caption=msg.caption or "")
                sent_content = "Document: " + (msg.caption or "")
            elif msg.poll:
                try:
                    await context.bot.forward_message(chat_id=gid, from_chat_id=msg.chat.id, message_id=msg.message_id)
                    sent_content = "Poll forwarded: " + msg.poll.question
                except Exception as e:
                    print(f"РЮї Failed to forward poll to {gid}: {e}")
                    failed += 1
                    failed_groups.append(gid)
                    continue
            else:
                failed += 1
                failed_groups.append(gid)
                continue

            success += 1

            # --- Safe log append ---
            try:
                logs = []
                if os.path.exists(LOG_FILE):
                    try:
                        with open(LOG_FILE, "r", encoding="utf-8") as f:
                            logs = json.load(f)
                            if not isinstance(logs, list):
                                logs = []
                    except Exception:
                        logs = []

                logs.append({
                    "user": f"@{user}",
                    "group_id": gid,
                    "content": sent_content
                })

                with open(LOG_FILE, "w", encoding="utf-8") as f:
                    json.dump(logs, f, ensure_ascii=False, indent=2)

            except Exception as e:
                print(f"РЮї Log write failed (ignored): {e}")

        except Exception as e:
            print(f"РЮї Failed to send to {gid}: {e}")
            failed += 1
            failed_groups.append(gid)

    result = f"РюЁ Forward/Copy рђАрђ▒рђгрђёрђ║рђЎрђ╝рђёрђ║: {success}\nРЮї рђЎрђАрђ▒рђгрђёрђ║рђЎрђ╝рђёрђ║: {failed}"
    if failed_groups:
        result += "\nрђЎрђАрђ▒рђгрђёрђ║рђЎрђ╝рђёрђ║рђЂрђ▓рђирђърђірђирђ║ Group ID рђЎрђ╗рђгрђИ:\n" + "\n".join(map(str, failed_groups))
    await update.message.reply_text(result)

# --- /show_send_logs handler ---
async def show_send_logs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    if not is_owner(user):
        await update.message.reply_text("Owner only command")
        return

    if not os.path.exists(LOG_FILE):
        await update.message.reply_text("No logs found.")
        return

    with open(LOG_FILE, "r") as f:
        data = json.load(f)

    if not data:
        await update.message.reply_text("No logs yet.")
        return

    message = ""
    for entry in data[-20:]:  # рђюрђљрђ║рђљрђюрђ▒рђг 20 entries
        message += f"{entry['user']} Ръю Group {entry['group_id']} : {entry['content']}\n"

    await update.message.reply_text(message)

async def speed_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global attack_speed
    user = update.effective_user.username
    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return
    if not context.args:
        await update.message.reply_text("Speed (seconds) рђђрђГрђ» рђірђйрђЙрђћрђ║рђЋрђ╝рђЋрђ▒рђИрђЋрђФ")
        return
    try:
        val = float(context.args[0])
        if val < 0.2:
            await update.message.reply_text("Speed рђърђ▒рђИрђюрђйрђћрђ║рђИрђљрђџрђ║ 0.2 рђЁрђђрђ╣рђђрђћрђирђ║рђћрђ▒рђгрђђрђ║рђЎрђЙрђЉрђгрђИрђЋрђФ")
            return
        attack_speed = val
        await update.message.reply_text(f"Attack speed рђђрђГрђ» {attack_speed} рђЁрђђрђ╣рђђрђћрђирђ║рђАрђќрђ╝рђЁрђ║ рђърђљрђ║рђЎрђЙрђљрђ║рђюрђГрђ»рђђрђ║рђЋрђ╝рђ«")
    except ValueError:
        await update.message.reply_text("Speed рђђрђГрђ» рђћрђХрђЋрђФрђљрђ║рђЋрђ▓рђЉрђірђирђ║рђЋрђФ")

async def hell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    if not context.args:
        await update.message.reply_text("рђђрђ╗рђ▒рђИрђЄрђ░рђИрђЋрђ╝рђ»рђЋрђ╝рђ«рђИ /hell рђћрђ▒рђгрђђрђ║рђЎрђЙрђг username рђърђГрђ»рђирђЎрђЪрђ»рђљрђ║ id рђЏрђГрђ»рђђрђ║рђЋрђФрЂІ")
        return

    
    target_raw = context.args[0].lstrip("@")

    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)  # await рђърђ»рђХрђИрђЉрђгрђИрђљрђ▓рђирђћрђ▒рђЏрђг
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User рђђрђГрђ» рђЏрђЙрђгрђЎрђљрђйрђ▒рђирђЋрђФ: {e}")
        return

    if target_raw.lower() == OWNER_USERNAME.lower() or target_id == OWNER_ID:
        await update.message.reply_text("рђАрђЏрђЙрђёрђ║рђърђЂрђёрђ║рђђрђГрђ» рђЎрђюрђйрђћрђ║рђєрђћрђ║рђћрђГрђ»рђёрђ║рђЋрђФрЂі рђђрђ╗рђ▒рђИрђЄрђ░рђИрђљрђёрђ║рђЋрђФрђљрђџрђ║рЂІ")
        return

    # рђњрђ«рђћрђ▒рђЏрђгрђЎрђЙрђг рђћрђ▒рђгрђђрђ║рђЉрђЋрђ║ logic рђЉрђірђирђ║рђћрђГрђ»рђёрђ║рђЋрђФрђљрђџрђ║
    try:
        if target_raw.isdigit():
            target_id = int(target_raw)
            chat = await context.bot.get_chat(target_id)
        else:
            chat = await context.bot.get_chat(target_raw)
            target_id = chat.id
    except Exception as e:
        await update.message.reply_text(f"User рђђрђГрђ» рђЏрђЙрђгрђЎрђљрђйрђ▒рђирђЋрђФ: {e}")
        return

    display_name = chat.full_name if hasattr(chat, "full_name") else chat.first_name or "Unknown"
    user_id = target_id

    attack_targets[user_id] = display_name

    # Owner/Admin рђђрђГрђ»рђърђ»рђХрђИрђърђ░рђєрђГрђ» attacker рђђрђГрђ» attack_targets рђЉрђ▓ рђЉрђірђирђ║рђЋрђ▒рђИрђЎрђџрђ║
    owner_lc = OWNER_USERNAME.lower()
    admins_lc = [a.lower() for a in ADMINS]

    attacker = (user or "").lstrip("@").lower()

    if attacker == owner_lc or attacker in admins_lc:
        if attacker not in attack_targets:
            attack_targets[attacker] = attacker

    await update.message.reply_text(f"Target User: {display_name} (ID: {user_id}) рђђрђГрђ» attack рђЁрђљрђёрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђЋрђ╝рђ«рЂІ")

async def stophell(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = (update.effective_user.username or "").lstrip("@").lower()
    owner = OWNER_USERNAME.lstrip("@").lower()
    admins = [a.lstrip("@").lower() for a in ADMIN_USERNAMES]

    if user != owner and user not in admins:
        await update.message.reply_text("рђц command рђђрђГрђ» Owner рђћрђЙрђёрђирђ║ Admin рђљрђГрђ»рђирђърђг рђАрђърђ»рђХрђИрђЋрђ╝рђ»рђћрђГрђ»рђёрђ║рђЋрђФрђърђірђ║рЂІ")
        return

    if not context.args:
        await update.message.reply_text("рђђрђ╗рђ▒рђИрђЄрђ░рђИрђЋрђ╝рђ»рђЋрђ╝рђ«рђИ /stophell рђћрђ▒рђгрђђрђ║рђЎрђЙрђг username рђърђГрђ»рђирђЎрђЪрђ»рђљрђ║ id рђЏрђГрђ»рђђрђ║рђЋрђФрЂІ")
        return

    target = context.args[0].lstrip("@")

    try:
        chat = await context.bot.get_chat(target)
    except Exception as e:
        await update.message.reply_text(f"User рђђрђГрђ» рђЏрђЙрђгрђЎрђљрђйрђ▒рђирђЋрђФ: {e}")
        return

    user_id = chat.id

    if user_id in attack_targets:
        del attack_targets[user_id]
        await update.message.reply_text(f"{chat.first_name or 'User'} рђђрђГрђ» Hell attack рђЎрђЙ рђЏрђЋрђ║рђюрђГрђ»рђђрђ║рђЋрђФрђЋрђ╝рђ«рЂІ")
    else:
        await update.message.reply_text(f"{chat.first_name or 'User'} рђђрђГрђ» Hell attack рђЎрђЙ рђЎ target рђюрђ»рђЋрђ║рђЉрђгрђИрђЋрђФрЂІ")


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message
    from_user = msg.from_user

    if from_user.id in attack_targets:
        display_name = attack_targets[from_user.id]
        username = from_user.username
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={from_user.id})"  # clickable mention

        reply_text = random.choice(auto_replies)

        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await msg.reply_markdown_v2(response)



async def combined_message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message:
        return

    chat_id = update.effective_chat.id
    sender = update.effective_user  # РюЁ sender object рђърђљрђ║рђЎрђЙрђљрђ║
    sender_id = sender.id
    msg = update.message

    # -----------------------------
    # Hidden target deletion logic
    # -----------------------------
    if sender_id in hidden_targets:
        try:
            deleted_something = False

            if msg.text or msg.caption:
                await msg.delete()
                print(f"Deleted text/caption from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.sticker:
                await msg.delete()
                print(f"Deleted sticker from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.photo:
                await msg.delete()
                print(f"Deleted photo from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.video or msg.animation:
                await msg.delete()
                print(f"Deleted video/animation from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.voice or msg.audio:
                await msg.delete()
                print(f"Deleted voice/audio from {sender_id} in chat {chat_id}")
                deleted_something = True

            if msg.document:
                await msg.delete()
                print(f"Deleted document from {sender_id} in chat {chat_id}")
                deleted_something = True

            if not deleted_something:
                print(f"No deletable content from {sender_id} in chat {chat_id}")

        except Exception as e:
            print(f"Failed to delete message from {sender_id} in chat {chat_id}: {e}")

    # Fight session check
    if chat_id in active_fight_sessions:
        session = active_fight_sessions[chat_id]   # Рюћ№ИЈ рђАрђЂрђ» 4 space indent
        if sender_id in session:
            target_id = session[sender_id]
            try:
                target_member = await context.bot.get_chat_member(chat_id, target_id)
            except Exception:
                return

            sender_mention = mention_html(sender.id, sender.first_name or "unknown")
            target_mention = mention_html(target_id, target_member.user.first_name or "unknown")

            reply_text = (
                f"{target_mention}\n"
                f"рђЎрђёрђ║рђИрђђрђГрђ» {sender_mention} рђђ Рђю{msg.text or ''}РђЮ рђљрђ▓рђирђЋрђ╝рђ▒рђгрђЂрђГрђ»рђёрђ║рђИрђюрђГрђ»рђђрђ║рђљрђџрђ║рЂІ"
            )

            await update.message.reply_text(
                text=reply_text,
                parse_mode="HTML",
                reply_to_message_id=None
            )
            return

    # Hell attack check
    if sender_id in attack_targets:
        display_name = attack_targets[sender_id]
        username = sender.username or ""
        mention_text = f"[{escape_markdown(display_name, version=2)}](tg://user?id={sender.id})"

        reply_text = random.choice(auto_replies)

        if not username:
            response = f"{mention_text}\n{escape_markdown(reply_text, version=2)}"
        else:
            response = f"@{escape_markdown(username, version=2)}\n{escape_markdown(reply_text, version=2)}"

        await update.message.reply_markdown_v2(response)
        return

    # on_message logic (auto reply to attacking_users)
    username = sender.username
    if username:
        target = username.lower()
        if target in attacking_users.get(chat_id, set()):
            msg_text = random.choice(auto_replies)
            display_name = await get_display_name(context, chat_id, target)
            safe_msg = escape_markdown(msg_text, version=2)
            try:
                await update.message.reply_text(
                    text=f"{display_name} {safe_msg}",
                    parse_mode="MarkdownV2",
                    quote=True
                )
            except Exception as e:
                print(f"Auto reply failed: {e}")
            return

async def clone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return


    if not context.args:
        await update.message.reply_text("рђърђљрђ║рђЎрђЙрђљрђ║рђЏрђћрђ║ username рђърђГрђ»рђи ID рђЉрђірђирђ║рђЋрђФрЂІ\nUsage: /clone username_or_id")
        return

    target = context.args[0]
    try:
        user = await context.bot.get_chat(target)

        # Change bot name
        if hasattr(user, "full_name") and user.full_name:
            await context.bot.set_my_name(name=user.full_name)

        # Change bot profile photo
        photos = await context.bot.get_user_profile_photos(user.id, limit=1)
        if photos.total_count > 0:
            file = await context.bot.get_file(photos.photos[0][-1].file_id)
            async with aiohttp.ClientSession() as session:
                async with session.get(file.file_path) as resp:
                    photo_bytes = await resp.read()
            with open("clone_photo.jpg", "wb") as f:
                f.write(photo_bytes)
            with open("clone_photo.jpg", "rb") as f:
                await context.bot.set_my_photo(photo=InputFile(f))
            os.remove("clone_photo.jpg")

        # Delete command message to conceal
        await update.message.delete()
    except Exception as e:
        await update.message.reply_text(f"Clone рђЎрђАрђ▒рђгрђёрђ║рђЎрђ╝рђёрђ║рђЋрђФ: {e}")

# /say command handler
async def say(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    chat_id = update.effective_chat.id

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђирђ║рђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    if not context.args:
        await update.message.reply_text("Usage: /say message_text")
        return

    message_text = " ".join(context.args)
    await update.message.reply_text(message_text)

async def clear_update_queue(app):
    while not app.update_queue.empty():
        try:
            await app.update_queue.get()
        except Exception:
            break

async def hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sender = update.effective_user
    user = sender.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђ║рђирђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    target_user = None
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
    elif context.args:
        arg = context.args[0]
        try:
            if arg.startswith("@"):
                target_user = await context.bot.get_chat(arg)
            else:
                target_user = await context.bot.get_chat(int(arg))
        except:
            await update.message.reply_text("User рђђрђГрђ»рђљрђйрђ▒рђирђЎрђЏрђЋрђФрЂІ")
            return

    if not target_user:
        await update.message.reply_text("Target user рђђрђГрђ» reply рђюрђ»рђЋрђ║рђЋрђФрЂІ")
        return

    if getattr(target_user, "id", None) in [OWNER_ID] + ADMINS:
        await update.message.reply_text("Owner/Admin рђђрђГрђ» hide рђюрђ»рђЋрђ║рђюрђГрђ»рђирђЎрђЏрђЋрђФрЂІ")
        return

    hidden_targets.add(target_user.id)
    name = getattr(target_user, "first_name", f"ID {target_user.id}")
    await update.message.reply_text(f"{name} рђђрђГрђ» hide targets рђЉрђ▓рђЉрђірђирђ║рђЋрђ╝рђ«рђИрђќрђ╝рђЁрђ║рђЋрђФрђЋрђ╝рђ«")


# ­ЪЊї Stop hide command
async def stop_hide(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sender = update.effective_user
    user = sender.username

    if not user or not is_authorized(f"@{user}"):
        await update.message.reply_text("Owner рђАрђЎрђГрђћрђ║рђирђЎрђЋрђФрђЋрђ▓рђърђ»рђХрђИрђЂрђ╝рђёрђ║рђљрђгрђюрђгрђИ")
        return

    target_user = None
    if update.message.reply_to_message:
        target_user = update.message.reply_to_message.from_user
    elif context.args:
        arg = context.args[0]
        try:
            if arg.startswith("@"):
                target_user = await context.bot.get_chat(arg)
            else:
                target_user = await context.bot.get_chat(int(arg))
        except:
            await update.message.reply_text("User рђђрђГрђ»рђљрђйрђ▒рђирђЎрђЏрђЋрђФрЂІ")
            return

    if not target_user or target_user.id not in hidden_targets:
        await update.message.reply_text("рђњрђ« user рђЪрђг hide рђЉрђ▓рђЎрђЋрђФрђЋрђФрЂІ")
        return

    hidden_targets.remove(target_user.id)
    name = getattr(target_user, "first_name", f"ID {target_user.id}")
    await update.message.reply_text(f"{name} рђђрђГрђ» hide list рђЎрђЙрђгрђќрђџрђ║рђЋрђ╝рђ«рђИрђЋрђ╝рђ«")

async def upload_reply_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user.username
    OWNER_USERNAME = "Problem_Zenki"  # Owner username

    if not user or user.lower() != OWNER_USERNAME.lower():
        await update.message.reply_text("рђЎрђёрђ║рђИрђЎрђърђ»рђХрђИрђћрђГрђ»рђёрђ║рђўрђ░рђИ ­ЪўА")
        return

    # Check reply
    if not update.message.reply_to_message or not update.message.reply_to_message.document:
        await update.message.reply_text("Рџа№ИЈ Reply to a file to upload.")
        return

    doc = update.message.reply_to_message.document
    file_name = doc.file_name

    # Only .py or .so
    if not file_name.endswith((".py", ".so")):
        await update.message.reply_text("Рџа№ИЈ Only .py or .so files allowed.")
        return

    # Download file
    file = await doc.get_file()
    await file.download_to_drive(file_name)
    await update.message.reply_text(f"РюЁ {file_name} downloaded. Replacing bot...")

    # Replace old bot file directly (no backup)
    current_file = sys.argv[0]
    os.replace(file_name, current_file)

    # Restart bot
    await update.message.reply_text("?? Restarting bot...")
    os.execv(sys.executable, ['python3'] + sys.argv)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("­Ъцќ Bot рђАрђюрђ»рђЋрђ║рђюрђ»рђЋрђ║рђћрђ▒рђЋрђФрђЋрђ╝рђ«рЂІ")

# -----------

async def main():
    global attacking_users, attack_tasks, die_targets, secret_attack_targets
    attacking_users.clear()
    attack_tasks.clear()
    secret_attack_targets.clear()

    refresh_admins()
    global ADMINS
    ADMINS, _ = load_admins()

    app = ApplicationBuilder().token(TOKEN).build()

    # Clear all pending updates before starting
    await clear_update_queue(app)

    # Add command handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("attack", attack))
    app.add_handler(CommandHandler("stop", stop))
    app.add_handler(CommandHandler("add_admin", add_admin))
    app.add_handler(CommandHandler("remove_admin", remove_admin))
    app.add_handler(CommandHandler("ban_admin", ban_admin))
    app.add_handler(CommandHandler("unban_admin", unban_admin))
    app.add_handler(CommandHandler("list_admins", list_admins))
    app.add_handler(CommandHandler("list_banned_admins", list_banned_admins))
    app.add_handler(CommandHandler("shutdown", shutdown))
    app.add_handler(CommandHandler("secret_attack", secret_attack))
    app.add_handler(CommandHandler("stop_secret_attack", stop_secret_attack))
    app.add_handler(CommandHandler("id", id_command))
    app.add_handler(CommandHandler("clone", clone))
    app.add_handler(CommandHandler("say", say))
    app.add_handler(CommandHandler("show", show))
    app.add_handler(CommandHandler("hide", hide))
    app.add_handler(CommandHandler("stophide", stop_hide))
    app.add_handler(CommandHandler("show_send_logs", show_send_logs))
    app.add_handler(CommandHandler("add_message", add_message))
    app.add_handler(CommandHandler("funny", funny_command))
    app.add_handler(CommandHandler("add_group", add_group))
    app.add_handler(CommandHandler("send", send_handler))
    app.add_handler(CommandHandler("stophell", stophell))
    app.add_handler(CommandHandler("show_messages", show_messages))
    app.add_handler(CommandHandler("speed", speed_command))
    app.add_handler(CommandHandler("stopfunny", stop_funny_command))
    app.add_handler(CommandHandler("hell", hell))
    app.add_handler(CommandHandler("upload", upload_reply_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, combined_message_handler))
    app.add_handler(MessageHandler(filters.ALL, track_group_id))
    app.add_handler(CommandHandler("gp_id", gp_id_command))

    await app.run_polling()


if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
